<document>
  <properties>    
    <title>Guidelines</title>
  </properties>  
  <body>
    <!-- The body of the document contains a number of sections -->
    <section name="Guidelines">        
    
<p>Unitils started as a discussion group on unit testing. The result of these discussions is the list of guidelines found on this page.</p>

<p><a href="#1">1. Introduction</a></p>
<p><a href="#2">2. General Guidelines</a></p>
<ul>
    <li><p><a href="#2.1">2.1 Structure of a unit test</a></p></li>
    <li><p><a href="#2.2">2.2 Naming Conventions</a></p></li>    
    <li><p><a href="#2.3">2.3 Put unit tests in same package but separate source folder</a></p></li>
    <li><p><a href="#2.4">2.4 Create test data during setup</a></p></li>
    <li><p><a href="#2.5">2.5 Keep your test fixture simple</a></p></li>
    <li><p><a href="#2.6">2.6 Test boundary conditions</a></p></li>
    <li><p><a href="#2.7">2.7 Test public interface, not internals</a></p></li>
    <li><p><a href="#2.8">2.8 Keep test methods small</a></p></li>
    <li><p><a href="#2.9">2.9 Create independent unit tests</a></p></li>
    <li><p><a href="#2.10">2.10 Write tests while writing code</a></p></li>
    <li><p><a href="#2.11">2.11 Use reflection for equality checking</a></p></li>
    <li><p><a href="#2.12">2.12 Everyone tests or no one tests</a></p></li>
    <li><p><a href="#2.13">2.13 Fix broken tests immediately</a></p></li>
    <li><p><a href="#2.14">2.14 Use continuous integration</a></p></li>
    <li><p><a href="#2.15">2.15 Use build tool or IDE to run suites of tests</a></p></li>
    <li><p><a href="#2.16">2.16 Write test when fixing a bug</a></p></li>
    <li><p><a href="#2.17">2.17 Test new project code, not library code</a></p></li>
    <li><p><a href="#2.18">2.18 Test declared exceptions</a></p></li>
</ul>
<p><a href="#3">3. Database testing guidelines</a></p>
<ul>
    <li><p><a href="#3.1">3.1 Test with unit test databases</a></p></li>
    <li><p><a href="#3.2">3.2 Automate the maintenance of test databases</a></p></li>
    <li><p><a href="#3.3">3.3 Disable foreign key and not null constraints</a></p></li>
    <li><p><a href="#3.4">3.4 Testing simple CRUD methods</a></p></li>
    <li><p><a href="#3.5">3.5 Testing queries</a></p></li>
    <li><p><a href="#3.6">3.6 Testing bulk data manipulation methods</a></p></li>
    <li><p><a href="#3.7">3.7 Keep your test data files simple</a></p></li>
    <li><p><a href="#3.8">3.8 Make data sets test class specific</a></p></li>
    <li><p><a href="#3.9">3.9 Use a DTD in your test data files</a></p></li>
    <li><p><a href="#3.10">3.10 Do not test auto-generated fields</a></p></li> 
    <li><p><a href="#3.11">3.11 Modify database sequences</a></p></li>
    <li><p><a href="#3.12">3.12 Don’t use transactions</a></p></li>
</ul>
<p><a href="#4">4. O/R mapping testing guidelines</a></p>
<ul>
    <li><p><a href="#4.1">4.1 Test mapping with database</a></p></li>
    <li><p><a href="#4.2">4.2 Test non-trivial queries</a></p></li>
    <li><p><a href="#4.3">4.3 Test bulk data manipulation methods</a></p></li>
</ul>


<p>The guidelines are work in progress and are intended to be open source. We have a <a href="http://sourceforge.net/forum/forum.php?forum_id=642599">
guidelines forum</a> on which guidelines can be discussed and new ones can be proposed. We hope to hear from you. Feel free to post your comments.</p>


<br />    
<h2><a name="1">1. Introduction</a></h2>

<p>A unit test is a piece of code written by a developer that tests another piece of code. Usually a unit test 
executes some particular method in a particular context, and it checks if the outcome matches the expected one. 
Unit tests are independent of each other, so that the sequence in which they are executed is of no importance. 
They can be executed without user intervention, which makes them very useful as automatic regression tests.</p>



<h4>Why write unit tests?</h4>

<p>Unit tests ensure that a piece of code really works at the time of writing, and that it keeps on working after 
subsequent changes to the code. Unit testing will reduce the time you spend on debugging, and it will improve your 
designs. It will make sure you have confidence in the code. It is a great help when refactoring, since it gives 
you direct feedback in case you break something. Unit tests also act as documentation, since they show how a method 
should be used and what boundary conditions it can handle.</p>

<p>The number one argument against unit testing is that it takes too much time. This not true, it will save you time 
instead, because of its immediate and constant feedback, and since it greatly reduces the debugging efforts you have 
to spend afterwards. It will make sure you fix bugs early that you would have found late when following a no-unit 
testing approach. This doesn’t mean we ignore the fact unit testing takes time. It does take longer to write both 
code and unit tests, but the complete, correctly functioning product will be delivered earlier, and it will be much 
more maintainable afterwards.</p>

<p>The unit testing strategy is part of your project methodology and should be discussed in advance, in 
cooperation  with the customer. The customer must be aware of and agree with the fact that you choose the unit 
testing approach. He has to be aware of the fact that daily coding will take some more time, but that the eventual 
stable product will be delivered sooner.</p>

<p>Each of the unit-tests test only a small part of the code. There should also be other kinds of tests on 
the project that test the code as whole. Examples are integration tests, user acceptance tests and performance tests.</p>




<h4>Pragmatic unit testing</h4>

<p>There are many possible levels of doing unit-testing. Some people want to reach 100% code coverage: every 
line of code is used in at least one test. Of course this requires you to write lots and lots of tests, probably spending 
more time writing and maintaining tests than writing code.</p>

<p>The other extreme is writing no tests at all. We think the ideal lies somewhere in between. Adding a few unit tests 
for some piece of code already catches most of the bugs in that code while staying maintainable and keeping focus on the 
project code.</p>

<p>A possible set of unit tests per piece of code can include:</p>
<ul>
    <li><p>a test for the main flow (the happy path)</p></li>
    <li><p>tests for the main alternative flows</p></li>
    <li><p>tests for boundary conditions (such as null arguments)</p></li>
</ul>

<p>The main focus of the guidelines is to make unit-testing easy and maintainable. Writing a test shouldn't take much time and a 
test should not hinder you when code is being altered and refactored.</p>

<p>Deciding on a unit testing strategy means deciding which layers of the software system will be tested (GUI, business, 
database), and what tools and libraries will be used. What is best chosen highly depends on the project, but typically you 
would at least test the business and database layers.</p>



<h4>Unit testing libraries</h4>

<p>We’ve chosen to use following libraries to aid us in writing
unit tests:</p>

<ul>
    <li><p><a href="http://www.junit.org/">JUnit</a> - base test library</p></li>
    <li><p><a href="http://testng.org/">TestNG</a> - base test library</p></li>
    <li><p><a href="http://dbunit.sourceforge.net/">DbUnit</a> - tests using a database</p></li>
    <li><p><a href="http://www.easymock.org/">EasyMock</a> - simulating behavior</p></li>
</ul>

<p>Aside from these libraries there is also a library that we created our own, that helps 
implementing much of the functionality described in these guidelines: <b>Unitils</b></p>




<br />
<h2><a name="2">2. General Guidelines</a></h2>



<div class="section"><h3><a name="2.1"></a>2.1 Structure of a unit test</h3>


<h4>Short Description</h4>

<p>A unit test generally consists of following parts:</p>
<ul>
    <li><p>Class under test instance</p></li>
    <li><p>Test data instances (also called test fixture)</p></li>
    <li><p>Setup of test data</p></li>
    <li><p>Test methods</p></li>
    <li><p>Utility methods</p></li>
</ul>

<p><i>For each test method:</i></p>
<ul>
    <li><p>(Optional) Test specific setup</p></li>
    <li><p>Execution of the method under test</p></li>
    <li><p>Verification of the results, using assert statements</p></li>
</ul>



<h4>Description</h4>

<p>Test classes typically contain a data setup part and a test part. The setup part is performed in 
the setUp() method and contains the instantiation of the class under test instance and all objects that 
will be used as data during the test (See  <a href="#2.4">Create test data during setup</a>). 
The class under test instance is the object on which the tested methods are called. 
Typically there is only one such instance per test class and it should be created in the setUp() method.</p>

<p>Verification of results is performed by using assert statements. You should only add asserts if they are of value 
for the test (See <a href="#2.8">Keep test methods small</a>). If objects need to be compared, use Unitils’ ReflectionAssert 
instead of a regular assertEquals() (See <a href="#2.11">Use reflection for equality checking</a>). Assert statements can have 
messages as arguments that will be used when the assertion fails. These messages do not have much added-value and can therefore 
be left out. E.g. both assert statements in the example below give the same result, but it's less work to use the second version:</p>
 
<p><pre><code>  assertEquals(“Name is not equal”, “John”, result.getFirstName());
  assertEquals(“John”, result.getFirstName());</code></pre></p>

<p>All bad smells that you can have for regular code are also applicable to test code. Test classes can for 
example contain duplicate code or become too big because too many tests were added to them. You should
react to these smells as you would with normal code: refactor the code.</p>


<h4>Examples</h4>

<div class="source"><pre>
package org.unitils.util;

import junit.framework.TestCase;

/**
 * Test class for {@link UserAdmin}.
 * Contains tests with …
 */
public class UserAdminTest extends TestCase {

    /* Class under test */
    private UserAdmin userAdmin;                            <span class="code-comment">// Class under Test</span>

    /* A simple test user */                                <span class="code-comment">//</span>
    private User user;                                      <span class="code-comment">// Test Data (Fixture)</span>
                                                            <span class="code-comment">//</span>
    /* An administrator role */                             <span class="code-comment">//</span>
    private Role adminRole;                                 <span class="code-comment">//</span>


    /**
     * Initializes the test fixture.
     */
    protected void setUp() throws Exception {
        super.setUp();                                      <span class="code-comment">// Superclass Setup</span>

        userAdmin = new UserAdmin();                        <span class="code-comment">// Create Class under Test</span>

        user = new User(“John”, “Doe”);                     <span class="code-comment">//</span>
        adminRole = new Role(“Administrator”);              <span class="code-comment">// Test Data Setup</span>
    }


    /**
     * Test for method with …
     */
    public void testAddUser_oldEnough() {
        user.setAge(18);                                    <span class="code-comment">// Extra Test Setup</span>

        userAdmin.addUser(“jdoe”, user, adminRole);         <span class="code-comment">// Perform Test</span>

        User result = userAdmin.getUser(“jdoe”);            <span class="code-comment">//</span>
        assertEquals(“John”, result.getFirstName());        <span class="code-comment">// Verify Results</span>
        assertEquals(“Doe”, result.getLastName());          <span class="code-comment">//</span>
    }
}
</pre></div>

</div>







<div class="section"><h3><a name="2.2">2.2 Naming Conventions</a></h3>


<h4>Short Description</h4>

<p><i>For the test classes:</i></p>
<ul>
    <li><p>&lt;class name&gt; + <i>‘Test’</i></p></li>
    <li><p>If there are multiple test classes for one class: &lt;class name&gt; + &lt;description of tested behavior&gt; + <i>‘Test’</i></p></li>
</ul>

<p><i>For the test methods: </i></p>
<ul>
    <li><p>For the ‘happy path’:  ‘test’ + &lt;method name&gt;</p></li>
    <li><p>For all special cases: ‘test’ + &lt;method name&gt; + ‘_’ + &lt;description of special case&gt;</p></li>
</ul>


<h4>Description</h4>

<p>Proper naming of unit tests is important: it enables other developers and tools to easily locate the test classes and methods.</p>

<p>When creating a new test class, name the new class after the class that is being tested and add the suffix <i>‘Test’</i>. 
If there is more than 1 test class for a certain class (see <a href="#2.5">Keep your test fixture simple</a>) use the same 
convention, but add an extra name in front of ‘Test’. This extra name should give an indication of the kind of tests in this class.</p>

<p>The naming of test methods is similar, but instead of using a suffix, we use the prefix <i>‘test’</i>, followed by the name of 
the method under test (capitalize the first letter as with other method names). If there is more than 1 test for a certain method 
name all special cases by adding an underscore (‘_’) and an extra name. This extra name should again give an indication of the subject 
of the test.</p>


<h4>Examples</h4>
<p><table>
    <tr><td></td>               <td><b><i>Class/method under test</i></b></td>      <td><b><i>Test class/method</i></b></td></tr>
    <tr><td>Typical</td>        <td>ArrayList</td>                                  <td>ArrayList<b>Test</b></td></tr>
    <tr><td>Multiple tests</td> <td>ArrayList</td>                                  <td>ArrayList<b>Test</b></td></tr>
    <tr><td></td>               <td></td>                                           <td>ArrayList<b>SortingTest</b></td></tr>
    <tr><td></td>               <td></td>                                           <td>ArrayList<b>IteratorTest</b></td></tr>
    <tr><td>Happy path</td>     <td>add(int index, Object element)</td>             <td><b>test</b>Add()</td></tr>
    <tr><td>Special cases</td>  <td>add(int index, Object element)</td>             <td><b>test</b>Add<b>_nullElement</b>()</td></tr>
    <tr><td></td>               <td></td>                                           <td><b>test</b>Add<b>_negativeIndex</b>()</td></tr>
</table></p>

</div>




<div class="section"><h3><a name="2.3">2.3 Put unit tests in same package but separate source folder</a></h3>


<h4>Short Description</h4>

<p>Put test classes in the same package as the tested code but store them in a separate source tree.</p>


<h4>Description</h4>

<p>Test classes should be easy to locate. Creating test classes in the same package as the class under test and 
using the correct <a href="#2.2">naming conventions</a> enables you to find all tests of a class very quickly. Furthermore, 
sharing the same package will enable you, if necessary, to test protected and package-protected methods.</p>

<p>Test artifacts are only of use during development. They should not be included in the end-deliverables. Putting test code in 
a different source directory gives a clean separation of test code and production code. It will make it easier to create 
deliverables such as JARs and EARs that do not include any of the test classes.</p>


<h4>Examples</h4>

<p><code><pre>
    <b>src/main/java</b>      /org/unitils/util/StringUtils.java
    <b>src/main/resources</b> /project.properties
    <b>src/test/java</b>      /org/unitils/util/StringUtilsTest.java
    <b>src/test/resources</b> /unitils.properties
</pre></code></p>
</div>




<div class="section"><h3><a name="2.4">2.4 Create test data during setup</a></h3>


<h4>Short Description</h4>

<p>Put all non-trivial test data creation in the setUp() method of your test. </p>

<p><i>Test methods </i></p>

<ul>
    <li><p>can use objects that were created during the setup of the test class</p></li>
    <li><p>may perform some additional configuration of test data during their own setup</p></li>
</ul>


<h4>Description</h4>

<p>If you need non-trivial test data in your test methods, put them in instance variables of the test class. Initialize the 
instance variables during the setup phase of the test. This set of test data objects is called the fixture of the test. Trivial 
test data such as strings and integers are typically not added to the fixture and used directly as arguments in the test methods.</p>

<p>Putting test data in instance variables will promote reuse of test data and will keep test methods small and maintainable.</p>

<p>If needed, a test method can perform modifications to the test data. This extra setup should however be used 
as an exception and be limited to changing a few values of the already created test data. JUnit and TestNG execute the fixture methods
before each of the test methods so changing the test data will not cause problems for other test methods.</p>

<p>If the set of test data becomes too large (too many instance variables) and is incoherent, split the 
tests into multiple test classes (see <a href="#2.5">Keep your test fixture simple</a>). Because not all 
test data is used by every test, splitting up tests will also avoid creation of too much unused test data.</p>

<p>Note: When using JUnit 3, do not forget to call super.setUp(), since superclasses can setting up in the
setUp() method.</p>


<h4>Examples</h4>

<div class="source"><pre>
public class UserAdminTest extends TestCase {

    /* Class under test */
    private UserAdmin userAdmin;  

    /* A simple test user */                                <span class="code-comment">//</span>                     
    private User user;                                      <span class="code-comment">//</span>
                                                            <span class="code-comment">// Test Data (Fixture)</span>
    /* An administrator role */                             <span class="code-comment">//</span>
    private Role adminRole;                                 <span class="code-comment">//</span>


    /**
     * Initializes the test fixture.
     */
    protected void setUp() throws Exception {
        super.setUp();

        userAdmin = new UserAdmin();
        user = new User(“John”, “Doe”);                     <span class="code-comment">// Test Data Setup</span>
        adminRole = new Role(“Administrator”);              <span class="code-comment">//</span>
    }


    /**
     * Test for method with …
     */
    public void testAddUser_oldEnough() {
        user.setAge(18);                                    <span class="code-comment">// Extra Test Setup</span>

        userAdmin.addUser(“jdoe”, user, adminRole);         <span class="code-comment">// Use Test Data</span>

        User result = userAdmin.getUser(“jdoe”);
        assertEquals(“John”, result.getFirstName());
        assertEquals(“Doe”, result.getLastName()); 
    }
}
</pre></div>

</div>




<div class="section"><h3><a name="2.5">2.5 Keep your test fixture simple</a></h3>


<h4>Short Description</h4>

<p>If the test fixture becomes too large and incoherent, split the test into multiple smaller tests.  As
names for these extra test classes, use &lt;class name&gt; + &lt;description of tested behavior&gt; + <i>‘Test’.</i></p>


<h4>Description</h4>

<p>Grouping too many (incoherent) tests in the same test class can cause a test fixture to become large and incoherent. If this 
is the case, split up the test fixture by dividing the test methods over multiple test classes. Because test data is put in instance 
variables (See <a href="#2.4">Create test data during setup</a>) you can easily spot incoherent test classes: they contain lots of instance 
variables that are only used by some of the test methods.</p>

<p>Try to find a logical group of test methods and move them to a new test class. Name this new test class as follows: the original 
test class name, followed by a name that characterizes this new group, followed by ‘Test’.</p>


<h4>Examples</h4>

<p>Suppose you have a test class for a class named UserAdmin
that contains code for maintaining users and their roles.</p>

<div class="source"><pre>
public class UserAdminTest extends TestCase {

    /* A simple test user 1 */                              <span class="code-comment">//</span>
    private User user1;                                     <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    /* A simple test user 10 */                             <span class="code-comment">// Test Data (Fixture)</span>
    private User user10;                                    <span class="code-comment">//  that is too large</span>
                                                            <span class="code-comment">//</span>
    /* An administrator role 1 */                           <span class="code-comment">//</span>
    private Role adminRole1;                                <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    /* An administrator role 10 */                          <span class="code-comment">//</span>
    private Role adminRole10;                               <span class="code-comment">//</span>


    /**
     * Test for method with …
     */
    public void testAddUser1() {
    }

    /**
     * Test for method with …
     */
    public void testAddRole1() { 
    }

    ...
}
</pre></div>

<p>This class clearly contains a fixture that is too large, so we should split the test class into multiple test classes. We could 
for example create a new class named UserAdmin<b>Roles</b>Test and move all roles related tests and test data out of the 
UserAdminTest class to this new class.</p>

<div class="source"><pre>
public class UserAdminTest extends TestCase {

    /* A simple test user 1 */                              <span class="code-comment">//</span>
    private User user1;                                     <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">// User Test Data (Fixture)</span>
                                                            <span class="code-comment">//</span>
    /* A simple test user 10 */                             <span class="code-comment">//</span>
    private User user10;                                    <span class="code-comment">//</span>


    /**                                                     <span class="code-comment">//</span>
     * Test for method with …                               <span class="code-comment">//</span>
     */                                                     <span class="code-comment">//</span>
    public void testAddUser1() {                            <span class="code-comment">// User Tests</span>
    }                                                       <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">//</span>
}

public class UserAdminRolesTest extends TestCase {

    /* An administrator role 1 */                           <span class="code-comment">//</span>
    private Role adminRole1;                                <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">// Roles Test Data (Fixture)</span>
                                                            <span class="code-comment">//</span>
    /* An administrator role 10 */                          <span class="code-comment">//</span>
    private Role adminRole10;                               <span class="code-comment">//</span>


    /**                                                     <span class="code-comment">//</span>
     * Test for method with …                               <span class="code-comment">//</span>
     */                                                     <span class="code-comment">//</span>
    public void testAddRole1() {                            <span class="code-comment">// Roles Tests</span>
    }                                                       <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">//</span>
}
</pre></div>

</div>




<div class="section"><h3><a name="2.6">2.6 Test boundary conditions</a></h3>


<h4>Short Description</h4>

<p>Write tests for all boundary conditions of the tested method. Only boundary conditions that a method can handle according to its interface
(javadoc and arguments) should be tested.</p>

<p><i>For every boundary condition do one of the following:</i></p>

<ul>
    <li><p>write a unit test for this boundary condition</p></li>
    <li><p>add a precondition to the javadoc that excludes this condition from the method’s contract.</p></li> 
</ul>


<h4>Description</h4>

<p>You should test the interface of a method. If a method’s interface (javadoc and arguments) does not prohibit a boundary value such as null,
the method should be able to handle it.</p>

<p>If a method shouldn’t be called with some boundary value:
change the signature. That is, put the constraint as precondition in the
javadoc of the method. This could be as easy as adding <i>not null</i> to the
parameter declaration in the javadoc.</p>

<p>If the method allows boundary values: create test cases for
these values. Following table shows the typical boundary values for which you
should write a test.</p>

<table>
    <tr><td><b><i>Argument</i></b></td>     <td><b><i>Boundary conditions</i></b></td></tr>
    <tr><td>Object</td>                     <td><b>null</b></td></tr>
    <tr><td></td>                           <td><b>boundary conditions of instance variables</b></td></tr>
    <tr><td>Numeric value</td>              <td><i>0</i></td></tr>
    <tr><td></td>                           <td><i>negative value</i></td></tr>
    <tr><td></td>                           <td><i>minimum and maximum</i></td></tr>
    <tr><td>String</td>                     <td><b>null</b></td></tr>
    <tr><td></td>                           <td><i>empty string</i></td></tr>
    <tr><td></td>                           <td><i>length equal to maximum length (if maximum defined)</i></td></tr>
    <tr><td></td>                           <td><i>length greater than maximum length (if maximum defined)</i></td></tr>
    <tr><td>Collections</td>                <td><b>null</b></td></tr>
    <tr><td></td>                           <td><i>empty collection</i></td></tr>
    <tr><td></td>                           <td><i>collection with duplicate elements</i></td></tr>  
</table>

<p>The conditions in bold are the minimal conditions for which a test needs to be written. Add extra boundary condition 
tests when necessary. For example, you should create tests for the length of a string argument when the method implementation 
has some kind of restriction on the length of a string.</p>

<p>Exception boundary conditions should also be tested. How to test such conditions is described in <a href="#2.18">Test declared exceptions</a>.</p>


<h4>Examples</h4>

<p>Suppose you have a class named UserAdmin that defines a method for adding a user. This method takes two arguments: a user and a role.</p>

<div class="source"><pre>
public class UserAdmin
{

    /**
     * Adds a user and links it to the given role.
     *
     * @param user the user to add
     * @param role the user’s role
     */
     public void addUser(User user, Role role) {        
        users.add(user.getName());
        roles.put(role.getName(), user)
    }
}
</pre></div>

<p>After writing the tests for the typical behavior of this method, we should also add test for the boundary conditions of the 
arguments. Note that the method’s javadoc doesn’t mention that the method cannot be called with null arguments.</p>

<p>You should now either, add the proper preconditions to the javadoc…</p>

<div class="source"><pre>
public class UserAdmin
{

    /**
     * Adds a user and links it to the given role.
     *
     * @param user the user to add, not null                <span class="code-comment">// Extra precondition</span>
     * @param role the user’s role
     */
     public void addUser(User user, Role role) {
        users.add(user.getName());
        roles.put(role.getName(), user)
     }
}
</pre></div>

<p>…or write a proper boundary condition test.</p>

<div class="source"><pre>
public class UserAdminTest extends TestCase {

    /**
     * Test for method for a null role argument.
     */
    public void testAddUser_nullRole() {
        userAdmin.addUser(user, null);                      <span class="code-comment">// Boundary cond. test</span>

        //validate result
        ... 
    }
}

</pre></div>

<p>If you look at the implementation of the method, you see that this test will fail initially. You should fix the bug by implementing 
the proper null handling in the method and then rerun the test until it's successful.</p>

</div>




<div class="section"><h3><a name="2.7">2.7 Test public interface, not internals</a></h3>


<h4>Short Description</h4>

<p>Only test the behavior as is described in the public interface and javadoc. The internal implementation should not be tested. Do not 
test trivial methods such as getters and setters. Only methods that contain logic should be tested. Only test protected methods if 
they are meant to be called directly by subclasses, for example utility methods in abstract base classes.</p>


<h4>Description</h4>

<p>The public interface of a class defines the behavior of the class. How a certain behavior is implemented is not important. 
Your tests should therefore not depend on how a class is implemented. Only testing the interface will make your tests less 
susceptible to change and refactorings. It will minimize the changes needed to your tests when changes to the implementation are made.</p>

<p>Tests should be written for methods that contain non-trivial logic. Trivial methods that contain no logic, such as getters
and setters or methods that do pure delegation to objects of other classes, should not be tested. These tests don't provide added-value 
and only increase the effort needed to maintain all tests.</p>


<h4>Examples</h4>

<p>Suppose you have following class, containing a non-trivial public method, a non trivial getter, a trivial setter and an 
internal implementation method.</p>

<div class="source"><pre>
public class User {
      

    /**
     * Adds a new role, the guest role will be added if user is null.
     *
     * @param role the role to add, null for guest role
     */
    public void addRole(Role role) {
        if (role == null) {
            role = createRole(“guest”);
            roles.add(role);
        }
    }


    /**
     * Getter for the age field.
     *
     * @return the age in years
     */
    public int getAge(){                                    <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
        // calculate age using birth date                   <span class="code-comment">// Non trivial getter</span>
                                                            <span class="code-comment">//</span>
        return age;                                         <span class="code-comment">//</span>
    }                                                       <span class="code-comment">//</span>


    /**
     * Setter for birthDate field.
     *
     * @param birthDate the date, not null
     */
    public void setBirthDate(Date birthDate){               <span class="code-comment">//</span>
        this.birthDate = birthDate;                         <span class="code-comment">// Trivial setter</span>
    }                                                       <span class="code-comment">//</span>


    /**
     * Factory method: creates a new role with the 
     * given name.
     * 
     * @return the role
     */
    protected Role createRole(String roleName) {            <span class="code-comment">//</span>
        return new Role(roleName);                          <span class="code-comment">// Non-public method</span>
    }                                                       <span class="code-comment">//</span>
}
</pre></div>

<p>In this example you should only write tests for the addRole() and getAge() method since these contain real logic. Testing the trivial
setBirthDate() method wouldn't give added-value. The createRole() method is used for the internal implementation and should therefore not 
be tested separately. It will implicitly be tested during the addUser() test.</p>

<p>Following code snippets show an example of a test that uses knowledge of a class's internal structure:</p>

<div class="source"><pre>
public class AuthenticatedUserRepository
{      
    private Map authenticatedUserMap = new HashMap();

    /**
     * Adds a new user.
     *
     * @param user the user to add, not null
     */
    public void addAuthenticatedUser(User user) {
        authenticatedUserMap.add(user.getSsn(), user);
    }


    /**
     * Verifies if the user is authenticated
     *
     * @return true if the user is authenticated, false otherwise
     */
    public boolean isAuthenticated(User user) {
        return authenticatedUserMap.get(user.getSsn()) != null;
    }


    /** 
     * Returns all users that are authenticated as a Map.
     *
     * return the map
     */
    public Map getAuthenticatedUserMap(){
        return authenticatedUserMap;
    }
}
</pre></div>

<p>Suppose you would create a test for addAuthenticatedUser() as follows:</p>

<div class="source"><pre>
public class UserAdminTest extends TestCase {

    /**
     * Tests the addAuthenticatedUser() method.
     */
    public void testAddAuthenticatedUser() {
        userAdmin.addAuthenticatedUser(user);
        
        //validate result
        Map authenticatedUserMap = userAdmin.getAuthenticatedUserMap();               
        User result = authenticatedUserMap.get(user.getSsn());                <span class="code-comment">// Implementation detail</span>
        ReflectionAssert.assertLenEquals(user, result);
    }
}
</pre></div>

<p>In this example, if you change the implementation of <i>addAuthenticatedUser</i> and <i>isAuthenticated</i> to
use the username as key in the map instead of the SSN, the test will break. This can be avoided by using <i>isAuthenticated</i>
in the unit test to verify that the <i>addAuthenticatedUser</i> behaves correctly.</p>

</div>




<div class="section"><h3><a name="2.8">2.8 Keep test methods small</a></h3>


<h4>Short Description</h4>

<p>Keep your test code as simple as possible. It should only contain:</p>

<ul>
    <li><p>an optional <i>small</i> setup of test data</p></li>
    <li><p>the call to the tested method</p></li>
    <li><p>a <i>limited</i> number of assertions</p></li>
</ul>


<h4>Description</h4>

<p>Tests should only contain the minimal amount of code needed to perform the test. This will keep your tests simple and maintainable.
Only write data setup and assertions that are really of value for your tests. There is no added-value in writing an assertion for a
field value if the function of the tested method is to calculate and update the value of another field.</p>

<p>Unitils’ ReflectionAssert can aid in only comparing values that are important for the test 
(See <a href="#2.11">Use reflection for equality checking</a>). It can be configured to perform a 
lenient comparison: ignore fields for which the expected object contains java default (null/0) values and ignore the order of collections.</p>


<h4>Examples</h4>

<div class="source"><pre>
public class UserTest extends TestCase {

    private User user;

    /**
     * Initializes the test fixture.
     */
    protected void setUp() throws Exception {
        super.setUp();

        user = new User("john");
    }


    /**
     * Test method for setting the age.
     */
    public void testSetAge() {
        user.setBirthDate(parseDate("20/05/1957");

        assertEquals(50, user.getAge());
        assertEquals(“john”, user.getName());               <span class="code-comment">// Useless assertion</span>
    }
}
</pre></div>

<p>There is no reason for verifying the name of the User object in this test. The code in this test should be limited
to testing the age only. On the one hand, this improves the readability of this test. On the other hand, it makes the test more 
maintainable because it is no longer dependent on the fact that the tested object was intialized with "john" as its name.</p>

</div>





<div class="section"><h3><a name="2.9">2.9 Create independent unit tests</a></h3>


<h4>Short Description</h4>

<p>A unit test should not depend on the prior execution of another unit test. All tests should be independent of each other. One should be able to run
each of the tests on its own.</p>


<h4>Description</h4>

<p>The sequence in which test methods are called is not guaranteed. Unit tests should therefore never rely on any execution
sequence. The test fixture must be completely (re-)initialized in the setup and test methods.</p>


<h4>Examples</h4>

<div class="source"><pre>
public class UserAdminTest extends TestCase {
    
    /**
     * Test method for adding a user.
     */
    public void testAddUser() {        
        userAdmin.addUser(user);
        
        assertEquals(user,userAdmin.getUser(“user”));
    }
    
    
    /**
     * Test method for removing a user.
     */
    public void testRemoveUser() {        
        userAdmin.addUser(user);                            <span class="code-comment">// Extra setup</span>
        
        userAdmin.removeUser(user);
        
        assertNull(userAdmin.getUser(“user”));
    }
}
</pre></div>

<p>The <i>testRemoveUser</i> method may also pass if it wouldn't perform the <i>addUser</i> call first, since the method <i>testAddUser</i> is executed 
first by the test runner, Nevertheless, the method <i>testRemoveUser()</i> includes a call to <i>addUser</i> in it's setup, to make sure it is 
independent of any other tests.</p>

</div>





<div class="section"><h3><a name="2.10">2.10 Write tests while writing code</a></h3>


<h4>Short Description</h4>

<p>Writing tests should be done while you are writing your code, not afterwards.</p>


<h4>Description</h4>

<p>When you are writing code, you have to test it in one way or another. So why not write a unit test directly? Writing unit tests immediately
makes sure all individual pieces work before trying out the whole. Bugs are more difficult to spot when testing your application 
through its end user interface, and the application has to be rebuilt and deployed each time you've done a fix. Also, the necessary test 
data is often not available or certain boundary conditions are difficult to simulate in integration testing mode.</p>

<p>Some people prefer writing tests <i>before</i> writing the actual code (test-first development). They start with writing the method's signature 
and write a test for the new functionality (which of course fails at that moment). Then they implement the code that makes this test succeed. 
Afterwards, tests are added for special cases and boundary conditions and the implementation is updated to make these tests pass. Although this 
approach is very viable, this way of coding doesn't work for everyone. We only advise you to write your test code at least while you are writing 
the code. In other words, the implementation is not completely finished if there are no unit tests.</p>

<p>Following approach is a mix between test-afterwards and test-first, that appears to work for many developers: 
You start with writing the signature and a first implementation of a method. Then you write a test for the main execution path and 
fix the implementation if necessary. After this, tests for extra boundary conditions and alternative flows are added <i>before</i> 
these alternative flows are implemented. For bug fixing the test-first approach also works very well: You start with writing a failing test that 
reveals the cause of the bug, then you make the change that makes this test pass.</p>

</div>





<div class="section"><h3><a name="2.11">2.11 Use reflection for equality checking</a></h3>


<h4>Short Description</h4>

<p>Use reflection to check equality instead of the equals() method. As a consequence, you should avoid using assertEquals() for object types other that 
basic types or value objects such as String, Integer etc.</p>


<h4>Description</h4>

<p>Equals methods for domain objects can contain business logic and should therefore not be used to test whether all inner values are equal.</p>

<p>Suppose for example that we want to verify that a User object returned by a DAO method matches an expected one. The equals() method of this user object 
 may be implemented to return true when they have the same social security number. If you use assertEquals() on 2 user instances you therefore only test 
 the equality of the social security number and not the equality of any of the other fields. Instead of using the equals() method, you should compare 
 each of the field values one by one. This can be done by accessing the field values through their getter methods (if the field has one) and then comparing 
 the values directly. Doing this manually however requires lots of coding and is error-prone. It’s better to do this automatically by using reflection.</p>

<p>Unitils provides a utility class that does this for you: <i>ReflectionAssert</i>.</p>

<p><i>ReflectionAssert</i> runs through the fields of the instances using reflection and compares each of the field values one by one. If
a field value is again an object instance, all its fields are recursively compared the same way. The ReflectionAssert class also offers functionality 
for non-strict comparison of fields. You can for example ignore field values for which the expected object contains a Java default value (null or 0), or test 
whether a collection contains some expected values, but not necessarily in the same order. This makes it possible to only compare what is realy important for the 
test (See <a href="#2.8">Keep test methods small</a>).</p>


<h4>Examples</h4>

<div class="source"><pre>
public class User {

    /* The social security number */
    private String ssn;

    /* The last name of the user */
    private String name;

    
    /**
     * Test whether the given object is the same user.
     */   
    public boolean equals(Object object) {        
        if (!(object instanceof User)) {
            return false;
        }
        
        User user = (User) object;                          <span class="code-comment">//</span>
        if (ssn == null &amp;&amp; user.ssn == null) {              <span class="code-comment">//</span>
            return true;                                    <span class="code-comment">// Business logic</span>
        }                                                   <span class="code-comment">//</span>
        return (ssn != null &amp;&amp; ssn.equals(user.ssn))        <span class="code-comment">//</span>
    }



user1.ssn  = 111          
user2.ssn  = 111        

user1.name = John             
user2.name = Tom

assertEquals(user1, user2)                      <b>true</b>
ReflectionAssert.assertEquals(user1, user2)     <b>false</b>
</pre></div>

</div>





<div class="section"><h3><a name="2.12">2.12 Everyone tests or no one tests</a></h3>


<h4>Short Description</h4>

<p>Whether or not to perform unit-testing is a decision that should be made at the level of a project.</p>


<h4>Description</h4>

<p>The unit testing strategy that you adopt in your team has great impact. It should be fully adopted and supported by everyone; there is no
use in some intermediate level. If you don’t go for it all-the-way, you will eventually end up writing or running no unit tests at all. </p>

<p>Why doesn’t it make sense when some of your team members are into unit testing and some don’t? Because members that do write them will
constantly be annoyed when others change their code and don’t maintain the tests, or by having to write unit tests for untested code of somebody 
else when changing it. In the end, they will also give up their good efforts and stop writing unit tests.</p>

<p>The best way to get everyone to write unit-tests is to convince the project manager of the necessity of such tests and let him impose
the unit test strategy on a project level.</p>

</div>





<div class="section"><h3><a name="2.13">2.13 Fix broken tests immediately</a></h3>


<h4>Short Description</h4>

<p>When a test is broken, fix it as soon as possible.</p>


<h4>Description</h4>

<p>The goal should be to keep the bar green as much as possible. This motivates people to write descent and working tests. If you don't
start with a green bar, then it is less likely that you notice additional failing tests. If there are too many broken tests, the motivation
to decreases to fix or to write any additional unit tests.</p>

<p>When you notice that you've broken a test, fix it at once. If this is not immediately possible, disable the test. 
This can be done by commenting out the test implementation and adding a logging statement for JUnit 3, by using the 
<i>@Ignore</i> annotation for JUnit 4, or by adding the test to an ignored group for TestNG.</p>

</div>





<div class="section"><h3><a name="2.14">2.14 Use continuous integration</a></h3>

<h4>Short Description</h4>

<p>Only run the tests of the code that you’re working on. Rely on a continuous build system to perform the full regression suite.</p>


<h4>Description</h4>

<p>Manually running all of the tests over after each code change is time-consuming. Only run the tests that could be impacted by the code that you 
are have changed and let an automatic build system run the other tests. Typically, you only run the tests that verify the behavior of the class 
that you are changing. E.g. if you changed something in the User class, perform all tests on the User*Test classes.</p>

<p>The continuous build server should be configured to run all unit-tests after every commit to the version control system and immediately give feedback 
when somebody broke a test. Developers should immediately react by fixing the broken test. (See <a href="#2.13">Fix broken tests immediately</a>)</p>

</div>




<div class="section"><h3><a name="2.15">2.15 Use build tool or IDE to run suites of tests</a></h3>


<h4>Short Description</h4>

<p>Do not use a static definition of the test classes in a test suite, like for example JUnit’s TestSuite class, for executing all the unit tests in
you project. Tools exist that can dynamically generate a list of all unit tests that can be found in a source folder. You can use for example a build 
tool such as Ant or an IDE for this purpose.</p>


<h4>Description</h4>

<p>JUnit offers the possibility to create a group of tests by adding them to a test suite. You could for example add every test in a package
to a suite so that they can all be performed in a single run. Manually maintaining such suites however is asking for trouble. Each time you created a 
new test-class, you would have to manually add it to the test-suite. If you forget this, the tests will not be performed when the suite is run. 
After a while, a lot of 'hidden' tests will probably fail.</p>

<p>Build tools like ant and IDEs like Eclipse and IntelliJ can automatically create these test suites for you, so that you are sure that 
every test is being performed.</p>


<h4>Examples</h4>

<p>Ant build-script for running all your tests in your test source folder:</p>

<div class="source"><pre>
&lt;junit printsummary=&quot;yes&quot; haltonfailure=&quot;true&quot;&gt;

    &lt;classpath&gt;
        &lt;pathelement path=&quot;${project.classpath.junit}&quot;/&gt;
    &lt;/classpath&gt;

    &lt;formatter type=&quot;xml&quot;/&gt;
    &lt;batchtest fork=&quot;yes&quot; todir=&quot;${project.build}/test&quot;&gt;
        &lt;fileset dir=&quot;${project.source.test}&quot;&gt;
            <b>&lt;include name=&quot;**/*Test.java&quot;/&gt;</b>
        &lt;/fileset&gt;
    &lt;/batchtest&gt;

&lt;/junit&gt;
</pre></div>

</div>





<div class="section"><h3><a name="2.16">2.16 Write test when fixing a bug</a></h3>


<h4>Short Description</h4>

<p>If you fix a bug, also write a test for the fix. </p>


<h4>Description</h4>

<p>Although unit tests help improving the quality of your code dramatically, it is always possible that you code contains bugs. These bugs 
are typically intercepted in a later test-stage, such as during functional or acceptance testing.</p>

<p>When a bug is found and the code is modified to fix it, also write a unit test for this fix. You have to test it anyway, so why not simply 
writing a unit test. This also makes sure that the bug is not re-introduced at a later time (regression test). 
A typical way of handling bugs is to write a failing test that reveals the bug first, and then fix your code to make your test pass. 
(see <a href="#2.10">Write tests while writing code</a>)</p>

</div>





<div class="section"><h3><a name="2.17">2.17 Test new project code, not library code</a></h3>


<h4>Short Description</h4>

<p>Only test code that is being written or changed. Do not write unit tests for a project's legacy code unless you're modifying it. 
Do not write tests for libraries or non-project code.</p>


<h4>Description</h4>

<p>Unit tests should test code that is written on the project. A common situation is that your project contains legacy code with little or no unit tests, 
and that you want to adopt a more agile approach for future development. A good practice is to write unit tests for new code and for 
existing code that you modify or rewrite. Writing tests for existing code is often difficult because such code is usually not written in a 
test-friendly way. Most likely, this software is used in production, so it has already been tested and debugged thoroughly in other ways.</p>

<p>Unit tests should not test code of libraries, external services or other projects that you depend on. These libraries and external projects 
should have their own test suites.</p>


</div>





<div class="section"><h3><a name="2.18">2.18 Test functional exceptions</a></h3>


<h4>Short Description</h4>

<p>Write tests for exceptional conditions of functional nature, that are typically declared in the interface.</p>


<h4>Description</h4>

<p>Functional exceptions are boundary conditions that should be tested in a unit-test. Such exceptions are typically declared in a method's javadoc. 
If you use JUnit 3, you can do this by triggering the exceptional condition in a try-catch block and calling the <i>fail()</i> method if the 
expected exception was not thrown (see below for an example). When using JUnit 4 or TestNG, you can specify the expected exception in the <i>@Test</i>
annotation.</p>

<p>If a test method contains checked exceptions, and we're not dealing with a test for this specific exception, don't surround the method call with a try-catch 
but simply add a throws clause to the test method. Exceptional conditions that arise because of a bug in the code, e.g. <i>NullPointerException</i>s, should not be 
caught in a unit test. Let JUnit or TestNG handle these exceptions.</p>


<h4>Examples</h4>

<div class="source"><pre>
public class UserTest extends TestCase {

    /**
     * Test method for setting the age.
     */
    public void testSetAge() throws Exception {             <span class="code-comment">// No try-catch for</span>
                                                            <span class="code-comment">// NegativeAgeException</span>
        user.setAge(50);

        assertEquals(50, user.getAge());
    }

    /**
     * Test method for setting the age.
     */
    public void testSetAge_negative() {       
        try {
            user.setAge(-1);
            fail("Epected NegativeAgeException.");          <span class="code-comment">// No exception, so fail</span>
            
        } catch (NegativeAgeException e) {
            //expected                                      <span class="code-comment">//</span>
        }                                                   <span class="code-comment">// Expected flow</span>
                                                            <span class="code-comment">//</span>
        assertEquals(20, user.getAge());                    <span class="code-comment">//</span>
    }
}
</pre></div>

</div>







<br />
<h2><a name="3">3. Database testing guidelines</a></h2>

<p>The database layer is a very important though brittle layer. Since the database layer is implemented at two different levels (DAO layer +
database itself), bugs occur frequently because of mismatches between these two. To spot problems in the persistence layer instantly, unit tests 
should be written for the persistence layer as a whole (DAO layer + database itself). DBUnit (<a href="http://dbunit.sourceforge.net/">http://dbunit.sourceforge.net/</a>) 
is used as supporting technology.</p>



<div class="section"><h3><a name="3.1">3.1 Test with unit test databases</a></h3>


<h4>Short Description</h4>

<ul>
    <li><p>Write your database tests on a unit test database. A unit test database contains only database structure, no data.</p></li>
    <li><p>Give each developer a separate unit test database instance or schema.</p></li>    
</ul>


<h4>Description</h4>

<p>Unit tests should not require a database filled with test data. If they depend on existing data, it becomes very difficult to make changes to 
this data without breaking other tests. Developers will therefore rather add new data than changing existing records. As more data is added to
the database, this situation becomes more and more difficult to maintain.</p> 

<p>We need to have complete control over the database structure and test data for each test individually. This can be realized by using a unit 
test database containing only the database structure and no data. Every unit test will then insert a small set of test data before running the test
(See <a href="#3.7">Keep your test data files simple</a>).</p>

<p>To avoid that different developers interfere with each other when executing unit tests, each developer should be given a separate database instance 
or schema (See <a href="#3.2">Automate the maintenance of test databases</a>). These instances or schemas contain little or no data and can 
therefore easily be installed on a shared server or created as an extra schema on the existing development database.</p>


<h4>Examples</h4>

<p>The following schema represents a team with 3 developers. Every developer has it's own unit test database schema. The continuous build server, in this 
case Cruise Control, is also configured to run on a separate schema (UNIT_CRCO).</p>

<p>All the test databases are extra schemas that have been added to the development database.</p>

<div class="image-center"><img src="images/schema_per_user.png" /></div>


</div>





<div class="section"><h3><a name="3.2">3.2 Automate the maintenance of test databases</a></h3>


<h4>Short Description</h4>

<p>The maintenance of test databases should be automated as much as possible. The recommended way is to use a pull strategy, where database
updates are made available as scripts in the source control system and applied to the test database before running a test. Database updates can be 
performed incrementally or by recreating the database from scratch.</p>

<h4>Description</h4>

<p>Manually maintaining a database instance or schema for every developer is quite a lot of work. Much time can be saved by automating the 
maintenance. This can be done:</p>
<ul>
    <li><p><i><u>From scratch</u></i>: By dropping and recreating the test database each time a structure update occurs</p></li>
    <li><p><i><u>Incrementally</u></i>: By individually applying every update to the database structure</p></li>
</ul>

<p>The advantage of the from-scratch approach is the simplicity: You only have to maintain a script containing the complete database
definition in the form of DDL statements. If the script contains an error, you simply fix it. The script can either be maintained 
manually or exported from some modeling tool. A major drawback is that, when the database size grows, recreating a database from scratch 
takes a considerable amount of time.</p>

<p>To keep your developers motivated to write and run tests, wait times should be avoided whenever possible. Unless your database is small,
an incremental approach to database maintenance should be considered. Incremental updates to the database structure are performed almost 
without noticable delays. Also, since incremental updates are data-preserving, the same update scripts could be used to migrate 
test or production databases. A drawback of this approach is the increased complexity: If a DDL statement that contains an error was applied 
to a number of unit test database, you will have to make sure new script is executed that contains the fix for this error.</p>

<p>You can have the advantages of both approaches by combining an incremental and from-scratch approach as follows: Make sure the greater
part of database updates is applied incrementally. To clean up your scripts from time to time or to fix an error, you can recreate the database 
schemas from scratch.</p>

<p>For distributing the changes to the unit test databases, you can use either a push or a pull strategy:</p>
<ul>
    <li><p><i><u>Push strategy</u></i>: The developer performing the database structure change, applies the change to all unit-test databases, using some tool or script.</p></li>
    <li><p><i><u>Pull strategy</u></i>: Database changes are made available as scripts in a shared directory or in the version control system. 
        Newly created or updated scripts are applied to the test database before executing a database test.</p></li>
</ul>

<p>In absence of supporting tools, choosing a push strategy is the most obvious decision for a project, because it is simple to set up. You only 
have to write a simple tool or script that distributes the changes to all the databases. Nevertheless, a pull strategy offers nothing but 
advantages, especially when your scripts are maintained in a version control systems. This way, developers recieve update scripts along with the 
corresponding code changes. Before a test is run, these new scripts are be executed on the database, so code and database structure are always 
in synch. Another advantage is that maintenance is performed in a decentralized way. This allows developers to use a local test database, for 
example, when working on separate locations or at home.</p>

<p>Unitils' database maintainer can keep your test databases up-to-date using a pull strategy, supporting both the incremental and 
from-sratch ways. For more information, we refer to the <a href="tutorial.html#Unit test database maintenance">tutorial</a>.</p>
</div>



<div class="section"><h3><a name="3.3">3.3 Disable foreign key and not null constraints</a></h3>


<h4>Short Description</h4>

<p>Disable all foreign key and not null constraints in unit testing databases. This way, no more test data has to be inserted than required 
for the test. Automate the disabling process to reduce the burden of manual maintenance.</p>


<h4>Description</h4>

<p>Database tests have to be written with as few test data as possible. In this context, database constraints do more harm than good. Disabling 
foreign key and not null constraints makes sure we only have to insert the data that we need for the test, nothing more.</p>

<p>To reduce the burden and avoid forgetting it, the disabling of constraints should be automated.
<a href="tutorial.html#Unit test database maintenance">Unitils’ DBMaintainer</a> will automatically disable 
all constraints after having performed an update to the database.</p>


<h4>Examples</h4>

<p>Suppose we have an application with users that have a role, are member of an organization and have multiple email addresses:</p>

<div class="image-left"><img src="images/tables1.png" /></div>

<p>A test data set for a method that retrieves the email addresses for a user could be written as follows:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;dataset&gt;

    &lt;user id=&quot;1&quot; username=&quot;jdoe&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@gmail.com&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@post.be&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

<p>This data file contains all data we need for our unit test. If we would work with a unit test database with all constraints 
enabled, extra records and columns that are not relevant for the test need to be added to the data set:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;dataset&gt;

    &lt;user id=&quot;1&quot; username=&quot;jdoe&quot; name=&quot;Doe&quot; roleid=&quot;1&quot; companyid=&quot;1&quot; /&gt;

    &lt;role id=&quot;1&quot; rolename=&quot;admin&quot; /&gt;
    &lt;company id=&quot;1&quot; name=&quot;Ordina&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@gmail.com&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@post.be&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

<p>The presence of constraints not only makes us spend a lot more time writing data, but also the maintenance cost increases dramatically.
For example, if a new NOT NULL column is added to one of the tables, the data file must be changed, even though it has no impact on the actual test.</p>

</div>





<div class="section"><h3><a name="3.4">3.4 Testing simple CRUD methods</a></h3>


<h4>Short Description</h4>

<p>Unit tests for CRUD methods are very simple and all follow a similar structure. This guideline is intended for testing traditional DAO methods 
using a technology like JDBC. When using an O/R mapping tool like Hibernate, testing simple CRUD methods is not useful.</p>


<h4>Description</h4>

<p>Unit tests for read, create, update and delete methods are very simple and share a similar structure.</p>

<p>Result-check data files (see <a href="#3.6">Testing bulk data manipulation methods</a>) should not be used for checking if 
a create, update or delete method behaves as expected. This can be done very simply by using the interface of the DAO and the ReflectionAssert 
class. The examples show how these methods can be tested in a simple way.</p>

<p>When persistance is handled by a O/R mapping framework like Hibernate or JPA (EJB3 persistence), CRUD operations are implemented by the framework, 
and writing unit tests is not useful. Read <a href="#4.1">Test mapping with database</a> for more information on this topic.</p>

<h4>Examples</h4>

<p>Simple CRUD methods can be tested easily through the interface of the DAO. Here are for example the unit tests for the findById,
create, update and delete methods of the UserDAO class:</p>

<div class="source"><pre>
@DataSet
public class UserDaoTest extends BaseDAOTest {
    
    protected void setUp() throws Exception {
        newUser = new User(“john”, "doe");
    }
    
    
    public void testCreate() {
        userDao.create(newUser);
        User toVerify = userDao.findById(user.getId());
    
        ReflectionAssert.assertRefEqual(user, toVerify);
    }
    
    
    public void testUpdate() {
        User user = userDao.getUser(1);
        user.setName(“testUpdated”);
    
        userDao.update(user);
        User toVerify = userDao.findById(user.getId());
    
        ReflectionAssert.assertRefEquals(user, toVerify);
    }
    
    
    public void testDelete() {
        userDao.delete(existingUser);
        User toVerify = userDao.findById(existingUser.getId());
    
        assertNull(toVerify);
    }    
}
</pre></div>

<p>We have used following data file:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;dataset&gt;

    &lt;user id=&quot;1&quot; first=”jim” last="smith" /&gt;

&lt;/dataset&gt;
</pre></div>

<p>A separate test for findById() is not included. The correct behavior of this method is implicitly tested by the other test methods.</p>

</div>





<div class="section"><h3><a name="3.5">3.5 Testing queries</a></h3>


<h4>Short Description</h4>

<p>SQL or HQL queries are often complex and difficult to maintain. Unit tests are therefore very important, especially
for complex queries. Test data for testing queries should be very concise and only include columns on which query conditions are expressed.</p>


<h4>Description</h4>

<p>Unit tests can be very effective for guaranteeing the correctness of a query, especially for complex queries. They are invaluable 
for making sure that changes to the database didn't break any queries.</p>

<p>Following steps can be performed when writing a unit test for a query:</p>

<ul>
    <li><p>Create a test data set with one or a few records that should be included in the result of the query.</p></li>
    <li><p>Add one or a few records that should not be included in the result of the query.</p></li>
    <li><p>For each of these records, only add the primary key columns and the columns involved in join conditions and where clauses.</p></li>
    <li><p>Write a test that invokes the query method.</p></li>
    <li><p>Assert that the result is correct by verifying the values of the ID (primary key) field of the resulting objects.</p></li>
</ul>

<p><i><u>Explanation of these steps</u></i>: The complexity of a database query lies in the combination of join- and other conditions that make 
up the <i>WHERE</i> clause. To verify correctness of this <i>WHERE</i> clause, different test data records should be defined that are included in 
the result of the query, because of different reasons. A good test dataset also includes records that are not expected to appear in the result of 
the query. Make sure you only specify the data that is actually required for testing the query, i.e. the columns used in join and condition clauses. 
This will keep your datasets as small and maintainable as possible (See <a href="#3.7">3.7 Keep your test data files simple</a>).</p>



<h4>Examples</h4>

<p>The example shows a unit test for a query on a database that has following structure:</p>

<div class="image-left"><img src="images/tables2.png" /></div>

<p>Every user belongs to exactly one company. Companies can have a number of partnerships with other companies. The DAO method under 
test, <i>findPartnershipUsers</i>, returns a <i>List</i> of all users that belong to a company that have some kind of partnership with 
the given company.</p>

<div class="source"><pre>
public List&lt;User&gt; findPartnershipUsers(Company comp) {
    String query = &quot;select u.id, u.username, u.name, u.fname, u.roleid, u.company &quot;  
                   &quot;from user u, company c1, company c2, partnership p &quot; +
                   &quot;where u.companyid = c1.id &quot; +
                   &quot;  and p.company1id = c1.id &quot; +
                   &quot;  and p.company2id = c2.id &quot; +
                   &quot;  and c2.name = ?&quot;;    
    return invokeQuery(query);
}
</pre></div>

<p>We’ve written following unit test:</p>

<div class="source"><pre>
public void testFindPartnershipUsers() {
    List&lt;User&gt; foundUsers = userDao.findPartnershipUsers("MyCompany");
    ReflectionAssert.assertPropertyLenEquals("id", Arrays.asList(2), foundUsers);      
}
</pre></div>

<p>with this data file:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;dataset&gt;
    
    &lt;company id=&quot;1&quot; name=&quot;MyCompany&quot; /&gt;
    &lt;user id=&quot;1&quot; companyid=&quot;1&quot; /&gt;

    &lt;company id=&quot;2&quot; /&gt;    
    &lt;user id=&quot;2&quot; companyid=&quot;2&quot; /&gt;
    
    &lt;company id=&quot;3&quot; /&gt;
    &lt;user id=&quot;3&quot; companyid=&quot;3&quot; /&gt;
   
    &lt;partnership company1id=&quot;1&quot; company2id=&quot;2&quot; /&gt;
    &lt;partnership company1id=&quot;2&quot; company2id=&quot;3&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

<p>The data file defines 3 users, the first one being member of MyCompany, the second is member of a second company, which has a
partnership with MyCompany. The third user is member of company 3, which is a partner of company 2, but not a partner of MyCompany. 
Only the second user should be returned by the tested method, we therefore check whether a list is returned containing one user, with 
the id field equal to <i>2</i>.</p>

</div>




<div class="section"><h3><a name="3.6">3.6 Testing bulk data manipulation methods</a></h3>


<h4>Short Description</h4>

<p>For testing bulk insert, update or delete methods, which are cumbersome to test through the API of your DAOs, check the updated DB contents
with a DBUnit result data file at the end of your test.</p>


<h4>Description</h4>

<p>Database methods that perform bulk updates or deletes are often difficult to test. Verifying correctness of these methods through the interface of
a DAO and with regular assert methods, is sometimes cumbersome.</p>

<p>Unitils' <i>@ExpectedDataSet</i> annotation can be used to check the result of a test by comparing the contents of the database with a result data file. 
Only the tables and columns that you actually want to check should be included in the data file.</p>

<p>Result data files are very powerful: you can check almost anything with a simple XML file. However, using them should be avoided whenever possible. You
should first consider using methods of an existing DAO and assert statements to verify the results. When changing database structure, a number of data 
files will also have to be updated. The more data files you have, the more impact database refactorings will have.</p>


<h4>Examples</h4>

<p>Suppose you have a system in which users can place orders. A weekly batch job moves all orders that are older than a year to a history table. 
This history table cannot be queried by the application; we store the information for reporting purposes only. The batch job is
implemented using a call to a stored procedure. We have following table structure:</p>

<div class="image-left"><img src="images/tables3.png" /></div>

<p>In our application, nothing is foreseen to querying the archive tables. It is therefore a good idea to use a result data file to verify
the correct behavior of this stored procedure. Our unit test looks like the following:</p>

<div class="source"><pre>
@ExpectedDataSet
public void testArchiveOrders() {
    orderDao.archiveOrdersOlderThan(DateUtils.parseDate(&quot;21-05-2006&quot;);
}
</pre></div>

<p>And we have following data file:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;dataset&gt;

    &lt;order id=&quot;1&quot; date=&quot;20-05-2006&quot; /&gt;
    &lt;orderline id=&quot;11&quot; orderid=&quot;1&quot; /&gt;
    &lt;orderline id=&quot;12&quot; orderid=&quot;1&quot; /&gt;

    &lt;order id=&quot;2&quot; date=&quot;21-05-2006&quot; /&gt;
    &lt;orderline id=&quot;21&quot; orderid=&quot;2&quot; /&gt;
    &lt;orderline id=&quot;22&quot; orderid=&quot;2&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

<p>For verification following data set is used:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;dataset&gt;

    &lt;order id=&quot;2&quot; /&gt;
    &lt;orderline id=&quot;21&quot; /&gt;
    &lt;orderline id=&quot;22&quot; /&gt;

    &lt;arch_order id= &quot;1&quot; date=&quot;20-05-2006&quot; /&gt;
    &lt;arch_orderline id=&quot;11&quot; arch_orderid=&quot;1&quot; /&gt;
    &lt;arch_orderline id=&quot;12&quot; arch_orderid=&quot;1&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

</div>





<div class="section"><h3><a name="3.7">3.7 Keep your test data files simple</a></h3>


<h4>Short Description</h4>

<ul>
    <li><p>Use DBUnit’s <a href="http://www.dbunit.org/apidocs/org/dbunit/dataset/xml/FlatXmlDataSet.html">FlatXMLDataSet</a> format for your data files</p></li>
    <li><p>Add no more data than necessary. Only fill ID columns, join condition columns and where condition columns.</p></li>
    <li><p>When data files grow too large or become incoherent, split your class in multiple test classes or create method-specific data files.</p></li>
</ul>


<h4>Description</h4>

<p>Putting test data in data files makes your unit test dependent on the database structure. Each time a change occurs to an existing
database column, a number of files need to be changed. Your unit tests should encourage database refactoring, not discourage it. Therefore, you should use as
few test data as possible, just enough to perform the test.</p>

<p>Data files should only fill columns that are involved in some kind of logic. This means filling up only the following columns:</p>

<ul>
    <li><p>ID columns</p></li>
    <li><p>Columns used in join conditions</p></li>
    <li><p>Columns used in the where clause of the query</p></li>
</ul>

<p>The columns specified above are part of a query’s logic. Other database fields used in the select queries are simply assigned to bean
properties in the tested method. Adding them to your test datasets or assert statements provides little added value to your test, but it 
greatly increases the maintenance cost.</p>

<p>If you run into data files with too much data, try to simplify them.</p>

<ul>
    <li><p>Refactor different tests in a test class to make them make use of the same data (if possible)</p></li>
    <li><p>If one or more methods need very specific test data, create a specific data file for these methods (like explained in the 
    <a href="tutorial.html#Database testing">tutorial</a>)</p></li>
    <li><p>If a group of related tests can be identified, split them up into a separate test class.</p></li>
</ul>

</div>

<div class="section"><h3><a name="3.8">3.8 Don't share data sets between test class</a></h3>

<h4>Short Description</h4>

<p>Don't share data sets between different test classes. Doing so will make it very difficult to make changes to test data without breaking 
other tests. A good practice is to have a test data set per test class and in some cases a specific data set for a test method.</p>
    
<h4>Description</h4>

<p>A common misconception is that time can be saved by creating one or a few general test data sets that can be reused by a large group of unit 
tests. This is in most cases not a good idea. The more unit tests reuse the same data set, the more brittle it becomes against changes.</p>

<p>Image the situation that you want to add a value for a column for testing a certain boundary condition. After doing the change, a number of 
existing tests appear to fail. As a reaction to this situation you will probably undo the change and try to find another way to test this boundary condition 
(or not test it at all). The simplest approach to avoid impacting other tests probably consists in adding new test records to the data set (although
this may also break existing tests). After a while, this will result in very large and incoherent datasets.</p>

<p>This doesn't mean you cannot share data among tests at all, because having more test data sets also brings along more maintenance. 
A good practice is to use a test data set per test class and in some cases a specific data set for a method.</p>

</div>

<div class="section"><h3><a name="3.9">3.9 Use a DTD in your test data files</a></h3>


<h4>Short Description</h4>

<p>Refer to a DTD that represents your database in DBUnit test data files, to enable code completion while editing them.</p>


<h4>Description</h4>

<p>Data files in DBUnit’s FlatXMLDataSet format can be written more quickly when enabling code completion by using a DTD. If you use Unitils’ 
database maintainer, a DTD is automatically created or updated on each developer’s workstation when his unit test database is changed.</p>


<h4>Examples</h4>

<p>The test data file below shows how to use a DTD on the local file system.</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE dataset SYSTEM &quot;../dtd/database.dtd&quot;&gt;
&lt;dataset&gt;

    &lt;user id=&quot;1&quot; username=&quot;jdoe&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@gmail.com&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@post.be&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

</div>





<div class="section"><h3><a name="3.10">3.10 Do not test auto-generated fields</a></h3>


<h4>Short Description</h4>

<p>Don’t test fields that are automatically filled up by the underlying framework or database, like generated keys or timestamps.</p>


<h4>Description</h4>

<p>Databases tables generally contain columns like the id, created_by, created_on, last_updated_by, last_updated_on or version columns.
They are used for identity, basic tracking (e.g. find the cause for data loss or corruption) and optimistic locking.</p>

<p>The implementation of tracking / optimistic locking should be handled application-wide, by the persistence mechanism and/or by DAO
superclass methods. It is therefore not necessary to test it over and over again for every DAO method.</p>

</div>





<div class="section"><h3><a name="3.11">3.11 Modify database sequences</a></h3>


<h4>Short Description</h4>

<p>When using identity / auto-increment columns or sequences, make sure their values are high enough value before running tests. This way they
don’t interfere with the test data.</p>


<h4>Description</h4>

<p>When a new sequence is created, it should be initialized to a sufficiently high value, to make sure auto generated ids and values don’t clash
with the ids and values of the test data files. When using Unitils' database maintainer for managing test database schema's, sequences and identity 
columns are automatically set to a configurable value.</p>

</div>





<div class="section"><h3><a name="3.12">3.12 Don’t use transactions</a></h3>


<h4>Short Description</h4>

<p>Don’t run unit tests in a transaction, instead use auto-commit.</p>


<h4>Description</h4>

<p>In production code, DAO methods are always executed in a transaction. Some argue that DAO methods need also to be executed in a
transaction, so that the tests closely resemble the real situation. Running them in a transaction however also has disadvantages:</p>

<ul>
    <li><p>When debugging tests using the IDE’s debugger, the data updates executed so far are not visible in a database query console like Toad or SqlPlus.</p></li>
    <li><p>Failing tests are difficult to debug if the transaction rolled back all changes to the database.</p></li>
    <li><p>Extra baseline code is required to enable transactions in unit tests.</p></li>
</ul>

</div>






<br />
<h2><a name="4">4. O/R mapping testing guidelines</a></h2>

<p>The past few years, most projects use some form of Object-Relational mapping framework such as Hibernate or an implementation of JPA (EJB3) Persistence. 
The use of such a mapping tool greatly simplifies the persistence layer in an application. Errors can still exist in the mapping of the domain objects with 
the database or in queries written in HQL or EJB3 QL. Unit tests remain valuable to help finding these errors quickly and efficiently.</p>

<p>The guidelines described in the <a href="#3">Database testing guidelines</a> also apply to testing with Hibernate. This chapter explains the specifics when
testing with Hibernate.</p>


<div class="section"><h3><a name="4.1">4.1 Test mapping with database</a></h3>


<h4>Short Description</h4>

<p>Unit tests for simple CRUD methods are overkill when using Hibernate. Instead, use a generic test that verifies the complete mapping with the database.</p>


<h4>Description</h4>

<p><a href="#3.4">Testing simple CRUD methods</a> explains how CRUD methods can be tested when using plain old JDBC. When using Hibernate, the correct functioning 
of simple CRUD depends mainly on the correct mapping of the domain model objects with the database. Here are some typical mapping problems:</p>

<ul>
    <li><p>Expected table or column is missing in the database</p></li>
    <li><p>Database table or column has a different name as specified in the mapping</p></li>
</ul>

<p>Of course, these problems are usually easy to trace and to fix, but adding a unit test that verifies the complete mapping with the database at once, 
makes sure these problems are discovered very soon. This is a very cheap solution, since you only have to define this unit test once. Experience on projects 
has learnt us that this test ends up to be one of the most valuable tests in the test suite.</p>

<p>The Unitils project provides a test that checks the mapping of domain and database for Hibernate. The test works for both a configuration with Hibernate 
XML mapping files as when using annotations. For more information we refer to the <a href="tutorial.html#Testing with Hibernate">tutorial</a>.</p>


<h4>Examples</h4>

<div class="source"><pre>
public class HibernateMappingTest extends BaseHibernateDAOTest {

    public void testMappingToDatabase() {
        HibernateUnitils.assertMappingWithDatabaseConsistent();
    }
}

</pre></div>

<p>Suppose the Person class is mapped with the PERSON column in the database using Hibernate. We add a phoneNumber property to the Person class, 
but forget to add this column in the database. The <i>HibernateMappingTest</i> now fails with the following message:</p>

<div class="source"><pre>
AssertionFailedError: Found mismatches between Java objects and database tables. 
Applying following DDL statements to the database should resolve the problem: 
alter table PERSON add column firstName varchar(255);
</pre></div>

</div>




<div class="section"><h3><a name="4.2">4.2 Test non-trivial queries</a></h3>


<h4>Short Description</h4>

<p>Add unit tests for methods that implement HQL queries. The same rules apply as for testing queries in plain old JDBC.</p>


<h4>Description</h4>

<p>The guideline <a href="#3.5">Testing queries</a> explains how maintainable unit tests can be written for queries. The same rules 
apply for testing with HQL queries. The example included in this guideline is also applicable in an O/R mapping context.</p>

</div>






<div class="section"><h3><a name="4.3">4.3 Test bulk data manipulation methods</a></h3>


<h4>Short Description</h4>

<p>Add unit tests for methods that implement bulk data manipulation. The same rules apply as for testing such methods written in plain old JDBC. Make sure 
the Hibernate Session is flushed before you access the test database trough plain old JDBC, without the intervenience of Hibernate.</p>


<h4>Description</h4>

<p>The guideline <a href="#3.6">Testing bulk data manipulation methods</a> explains how unit tests can be written for bulk data manipulation methods. 
The same rules apply for testing with such methods written in HQL.</p>

<p>Make sure that, when comparing the database contents with a result data file, the Hibernate session is flushed. Otherwise, the update that you 
want to test will most probably not be executed on the database yet when you perform the check. When making use of Unitils, the Hibernate session is automatically 
flushed before doing the check.</p>

</div>

<br />
<br />



        
    </section>
  </body>
</document>