 -----
 Tutorial
 -----
 -----

Tutorial
~~~~~~~~

    Unit testing should be easy and intuitively... at least in theory. Real-life projects
    typically span multiple layers, are data-driven and use middleware technologies such as EJB and Hibernate.

    Unitils originated out of an attempt to get a more pragmatic view on unit testing that involves some
    typical unit testing frameworks such as DbUnit and EasyMock. It started as a set of guidelines and
    eventually resulted in an open source library containing utilities that facilitate the application of these guidelines.

    This tutorial will show you what Unitils can do for your projects, using examples.
    It is merely an introduction to Unitils, more in-depth documentation can be found in the {{{apidocs/index.html}javadoc}} of the modules.
    The testing guidelines that are behind the features can be found on the {{{guidelines.html}guidelines page}}.


* Getting started
~~~~~~~~~~~~~~~~~

** Configuration
~~~~~~~~~~~~~~~~
    This section explains how the configuration of Unitils works. If you want to learn how you can setup Unitils to get started quickly, read the {{{cookbook.html}cookbook}}.
    
    As with many projects, Unitils needs some configuration of its services. By default, there are 3 levels
    of configuration, each level overriding the settings of the previous one:

    [[1]] <unitils-defaults.properties>: default configuration that is shipped within the distribution of Unitils

    [[2]] <unitils.properties>: can contain project-wide configuration

    [[3]] <unitils-local.properties>: can contain user-specific configuration

    []

    The first file, unitils-defaults.properties, contains default values and is packaged in the Unitils jar. There is no need to make changes
    to this file, but it can be used as reference, since it contains all possible configuration settings for Unitils.

    The second, unitils.properties, can override the defaults and is typically used to set values for configuration settings for all developers
    on a project. For example if your project uses an oracle database, you can create a unitils.properties file
    that overrides the driver class name and url properties as follows:

+-----+
dataSource.driverClassName=oracle.jdbc.driver.OracleDriver
dataSource.url=jdbc:oracle:thin:@yourmachine:1521:YOUR_DB
+-----+

    The file is not required, but if you create one, it should be placed somewhere in the classpath of your project. To get you started, 
    you can find a sample file that contains most commonly used configuration settings in following {{{unitils.properties}unitils.properties}} template.

    The last file, unitils-local.properties, is also optional and can contain settings that override the project settings and is used for
    defining per-user settings. For example, if each user uses its own unit-test database schema, you can
    create a unitils-local.properties for each user that contains the corresponding schema, username and password:

+-----+
dataSource.schemaName=test_john
dataSource.userName=john
dataSource.password=secret
+-----+

    Each of these unitils-local.properties files should be placed in the corresponding home folders of the user (<System.getProperty("user.home")>). 
    A typical local configuration can be found in following sample {{{unitils-local.properties}unitils-local.properties}} template.

    The name of the local file, unitils-local.properties, is also defined by a property. This makes it possible to use different names for each
    of the projects you are working on. For example, suppose you are working on a project named projectOne and want to start a new project
    named projectTwo. Adding following property to the unitils.properties of projetTwo will let Unitils use projectTwo-local.properties
    as local properties file for the project:

+-----+
unitils.configuration.localFileName=projectTwo-local.properties
+-----+


** Making your test Unitils-enabled
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Unitils offers services to test classes through a test listener system. To enable Unitils to provide services to your tests, you first have to Unitils-enable them.
    This can be done easily by (indirectly) extending from a Unitils base test-class. Currently there are base classes for the major test frameworks:

    * <<{{{http://www.junit.org/}JUnit3}}>>: org.unitils.UnitilsJUnit3

    * <<{{{http://www.junit.org/}JUnit4}}>>: org.unitils.UnitilsJUnit4

    * <<{{{http://testng.org/}TestNG}}>>: org.unitils.UnitilsTestNG

    []

    As an example, suppose you have a JUnit3 test that you want to Unitils-enable:

+-----+
import org.unitils.UnitilsJUnit3;

public class MyTest extends UnitilsJUnit3 {
}
+-----+

    Typically you would create your own base test class containing some utility behavior common for all your tests, e.g. datasource injection, and
    then let this base class extend from one of the Unitils base classes.

    For JUnit4 it is also possible to add a @RunWith annotation instead of extending from the base class:

+-----+
import org.junit.runner.RunWith;
import org.unitils.UnitilsJUnit4TestClassRunner;

@RunWith(UnitilsJUnit4TestClassRunner.class)
public class MyTest {
}
+-----+

    It is possible to Unitils-enable an existing test superclass. You might for example want to use {{{http://www.springframework.org}Spring}}'s AbstractDependencyInjectionSpringContextTests,
    which is a subclass of JUnit 3's TestCase, as superclass for a range of tests. You also want to make use of Unitils' services in some way. In this case, you can create a custom Unitils-enabled
    superclass by copying the source code of Unitils' provided superclass for the test framework that you like to use (in this case, this is UnitilsJUnit3), and by letting it extend 
    AbstractDependencyInjectionSpringContextTests instead of TestCase.

** Module system
~~~~~~~~~~~~~~~~
    Before starting with the examples, let's first take a look at some of the concepts used in Unitils and how it functions under the hood.

    Unitils is structured as an easy extensible system of modules. Each of these modules offers some type of service to a test by listening to the
    execution of the test and invoking the correct service behavior when needed. Each module provides an implementation of TestListener. The base classes 
    that Unitils provides (UnitilsJUnit3, UnitilsJUnit4, UnitilsTestNG), implement this listener functionality for the test framework that is used.

[images/unitils-modules.png] Unitils modules

   This mechanism offers a uniform way for providing extra services to your tests and a flexible way of adding services without having
   to change the superclass of the test. Adding new services is as easy as adding a new module and registering this module in one of Unitils' configuration files.

   Currently, following modules are available in Unitils:

   * <DatabaseModule>: unit-test database maintenance and connection pooling

   * <DbUnitModule>: test data management using DBUnit

   * <HibernateModule>: Hibernate configuration support and automatic database mapping checking

   * <EasyMockModule>: support for creating mocks and lenient reflection argument matching

   * <InjectModule>: support for injecting (mock) objects into other objects

   * Planned: support for JPA.




* Database testing
~~~~~~~~~~~~~~~~~~
    Unit tests for the database layer are extremely valuable in enterprise applications, but are often abandoned because of their complexity.
    Unitils greatly reduces this complexity, making database testing simple and maintainable. The following sections describe the database
    support by a number of simple examples. For an elaborate description of the guidelines, read the database testing guidelines.



** Managing test data with DbUnit
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Database tests should be run on a unit test database, having complete and fine grained control over the test data that is used. Unitils
    builds further on DBUnit for providing support for test data sets. Following code section provides a simple example of a database unit test with Unitils' DbUnit support.

    Let's say we have UserDAO with a simple findByName method for retrieving a user based on it's first and last name. The unit test looks as follows:

+-----+
public void UserDAOTest extends BaseDatabaseTest {

    @Test
    public void testFindByName {
        User johnDoe = userDao.findByName("doe", "john");
        assertEquals("jdoe", johnDoe.getUserName());
    }

    @Test
    public void testFindByMinimalAge {
        List<User> min18 = userDao.findByMinimalAge(18);
        assertEquals(1, min18.size());
        assertEquals("jack", min18.get(0).getUserName());
    }
}
+-----+

    The class level data file UserDAOTest.xml is located in the same package as the test class:

+-----+
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <user userName="jdoe" name="doe" firstname="john" />
</dataset>
+-----+

    The method testFindByMinimalAge has a specific data file named UserDAOTest.testFindByMinimalAge.xml:

+-----+
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <user userName="jack" age="18" />
    <user userName="jim" age="17" />
</dataset>
+-----+

    The class BaseDatabaseTest is a custom project base class, that is implemented as a database test superclass. For an example of such a base class, we refer to the {{{cookbook.html}cookbook}}.
    The DatabaseTest annotation in the test superclass marks the test as being a database test, instructing Unitils to look for DBUnit datafiles to load. Unitils automatically looks
    for a data file named <className>.xml. All existing data in the tables specified in the dataset is deleted, and the data
    in the datafile is inserted. DbUnit's FlatXMLDataSet is used as the file format.

    For methods needing very specific data, it may be a good idea to use a method level dataset. Unitils automatically looks for files named <className>.<methodName>.xml, such
    as the file UserDAOTest.testFindByMinimalAge.xml in the example.

    The dataset to use can also be specified explicitly using the annotation @DataSet, as in the following example:

+-----+
@DatabaseTest
@DataSet(fileName = "UserDAOTest_general.xml")
public void UserDAOTest extends UnitilsJUnit4 {

    @Test
    public void testFindByName {
        User johnDoe = userDao.findByName("doe", "john");
        assertEquals("jdoe", johnDoe.getUserName());
    }

    @DataSet(fileName = "UserDAOTest_ages.xml")
    public void testFindByMinimalAge {
        List<User> min18 = userDao.findByMinimalAge(18);
        assertEquals(1, min18.size());
        assertEquals("jack", min18.get(0).getUserName());
    }
}
+-----+

   For checking the result of bulk update methods or stored procedures, that are difficult to check in Java code,
   Unitils offers support for result file checking.

   Following example tests a method that disables all user accounts that haven't been used for a whole year:

+-----+
@DatabaseTest
public void UserDAOTest extends UnitilsJUnit4 {

    @Test
    @ExpectedDataSet
    public void testDisableInactiveAccounts {
        userDao.disableInactiveAccounts();
    }
}
+-----+

    After having executed the method annotated with @ExpectedDataSet, the contents of the database are compared with
    the data file UserDAOTest.testDisableInactiveAccounts-result.xml (<className>.<methodName>-result.xml):

+-----+
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <user userName="jack" active="true" />
    <user userName="jim" active="false" />
</dataset>
+-----+

   When writing database tests, keep in mind following guidelines:

   * Use small sets of test data, containing as few data as possible. In your data files,
   only specifiy columns that are used in join columns or the where clause of the tested query.

   * Don't reuse data files too much. Make them test class and in some cases even test method specific.
   Changing the data becomes very difficult when multiple tests are using the same data files.

   * Limit the use of result data files. If you do use them, only specify include the tables and columns that are
   important and leave out the rest.

   * Use a database schema per developer. This allows developers to insert test data and run tests without interfering with each other.

   * Disable all foreign key and not null constraints on the test databases. This way, the data files need to contain no more
   data than absolutely necessary.

   To provide support with these 2 last features, Unitils offers automatic test database schema maintenance:





** Unit test database maintenance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    A powerful DBMaintainer is provided to automatically update each developer's database schema individually. Unitils' DBMaintainer
    will automatically check if database structure updates are available before running a database test, and apply them if necessary.
    
    The DBMaintainer uses DBMS specific functionality, such as for disabling constraints and updating sequences. The DBMaintainer will
    therefore only run properly when the property <database.dialect> is correctly set. Currently, there is support for following databases:
    
    * Oracle: Currently, only tested properly with Oracle 9i
    
    * Hsqldb: Tested with version 1.8.0
    
    * MySQL: Tested with version 5.0

    The database maintainer works as follows: The test script folder contains scripts that start with a version number and end on .sql, as in following example:

+-----+
dbscripts/ 001_initial.sql
           002_tracking_updates.sql
           003_auditing_updates.sql
+-----+

    The leading zeroes are only added to make sure the scripts are shown in proper sequence in a file explorer window, they are not required.

    If a script is added with version number 4, the database will execute this script, bringing the database to version 4. When an
    existing script is changed, e.g. 001_initial.sql is replaced with a new version, the database is cleared and recreated from scratch.
    Before doing an update, all data in the database is deleted, to avoid errors when adding not-null columns or adding foreign keys in update scripts.
    It is possible to specify a number of tables for which the data is preserved. You can also configure a number of database items
    (tables, views, sequences, ...) that are preserved. Look at the configuration section for more information.

    It is a good practice to add new update files for small database updates. This makes sure updates are executed very quickly. Once in a while,
    you can clean up the small update scripts and replace them with one large DDL script.

    After each update, the DBMaintainer performs following actions:

    * <Disable foreign key and not-null constraints>: To be able to work with the smallest possible test data sets, all foreign key and not null
    constraints on the test database are disabled.

    * <Update sequences>: All sequences and identity columns are updated to a sufficiently high initial value (1000 by default). This way, you can
    use fixed primary key values when inserting test data.

    * <Create a DTD>: A DTD that describes the structure of DbUnit's FlatXMLDataSet is created. This enables validness checking and auto-completion
    when writing test data files.

    The DBMaintainer is highly configurable. You can swith on or off things like constraints disabling, disable from scratch updates, ... Look at
    the configuration for more information!







** Testing with Hibernate
~~~~~~~~~~~~~~~~~~~~~~~~~

    An O/R mapping framework like Hibernate greatly simplifies the data access layer of an application. Unit tests remain valuable, for ensuring the
    mapping of the Hibernate mapped classes is always in sync with the database, and for easy and quick testing of HQL queries.

    Unitils provides out-of-the box configuration support for Hibernate. When properly configured, Unitils' database and DbUnit support can be used like
    described in database testing. 
    
    A HQL test can be tested exacltly the same way as described in managing test data with DbUnit. The only difference is that you extend a superclass
    that is configured as being a Hibernate test superclass (see configuration). 
    
    The @ExpectedDataSet annotation can also be used for result checking with a data file. Unitils will make sure the Hibernate Session is flushed before
    performing the check, to make sure all database updates performed during the test are actually executed on the database.

*** Testing the mapping
~~~~~~~~~~~~~~~~~~~~~~~

    Unitils is shipped with a ready-to-use unit test that verifies if the mapping of all your mapped classes is consistent with the database. This
    test is not automatically executed; you should write a unit test that looks like the following:

+-----+
public class HibernateMappingTest extends BaseHibernateTest {

    public void testMappingToDatabase() {
        HibernateAssert.assertMappingToDatabase();
    }
}
+-----+

    In this example, BaseHibernateTest is a custom project base class, that handles all Unitils-Hibernate configuration. See the cookbook for more information.
    The method HibernateAssert.assertMappingToDatabase() checks if any updates are required to the database to make it consistent with the Hibernate mapping. If yes,
    the test fails and the DDL statements that should be issued to the database that will make the mapping consistent are shown in the error message. E.g.
    
+-----+
alter table PERSON add column lastName varchar(255);
alter table PRODUCT add column barCode varchar(255);
+-----+








* Using reflection for assertion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

** Reflection versus equals()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    A typical unit test contains a part in which it will compare test result values with expected values. Unitils offers some
    assertion utilities to help you with this. 
    
    Let's start with an example of comparing 2 User instances having an id, a first and a last name:

+-----+    
public class User {

    private long id;
    private String first;
    private String last;


    public User(long id, String first, String last) {
        this.id = id;
        this.first = first;
        this.last = last;
    }
}

User user1 = new User(1, "John", "Doe");
User user2 = new User(1, "John", "Doe");
assertEquals(user1, user2);
+-----+

    You would expect that this assertion would be successful since both instances contain the same values. This is not
    the case however. User does not override the equals() method. Checking equals of 2 User instances is therefore the same
    as checking whether both instances are the same. In other words, the assertEquals actually results in user1 == user2 
    being tested which causes the assertion to fail.
    
    Suppose you would implement the equals method as follows:
    
+-----+    
public boolean equals(Object object) {
    if (object instanceof User) {
        return id == ((User) object).id;
    }
    return false;
}
+-----+    

    This is a totally reasonable implementation for your application logic, stating that 2 user instances are referring to 
    the same user when they have the same id. It does not help you however with your unit testing. Testing whether 2 objects
    are equal is now reduced to the test whether they have the same id:
    
+-----+        
User user1 = new User(1, "John", "Doe");
User user2 = new User(1, "Jane", "Smith");
assertEquals(user1, user2);
+-----+

    This assertion will be successful, which is probably not what you want. Best is just to avoid using equals() altogether 
    when comparing object values. One approach can be to do the comparisson of each of the values one by one:    
    
+-----+        
User user1 = new User(1, "John", "Doe");
User user2 = new User(1, "John", "Doe");
assertEquals(user1.getId(), user2.getId());
assertEquals(user1.getFirst(), user2.getFirst());
assertEquals(user1.getLast(), user2.getLast());
+-----+
    
    Unitils offers utilities that help you perform these checks more easily, through reflection. Using <ReflectionAssert.assertRefEquals>
    the above example could be re-written as follows:
    
+-----+
User user1 = new User(1, "John", "Doe");
User user2 = new User(1, "John", "Doe");
assertRefEquals(user1, user2);    
+-----+

    This assertion will loop over all fields in both objects and compare their values using reflection. For the above example, it will
    first compare both <id> field values, next both <first> field values and finally both <last> fields values. 
    
    If a field value itself is also an object, it will recursively be compared field by field using reflection. The same is true for 
    collections, maps and arrays. Their elements will be traversed and recusively be compared using reflection. 

    If a value is of a primitive type (int, long, ...) or one of the primitive wrapper types (Integer, Long, ...) it will be 
    compared by value (using ==). Following assertions, for example, will be successful:

+-----+
assertRefEquals(1, 1L); 

List<Double> myList = new ArrayList<Double>();
myList.add(1.0);
myList.add(2.0);
assertRefEquals(Arrays.asList(1, 2), myList); 
+-----+




** Lenient assertions
~~~~~~~~~~~~~~~~~~~~~
        
    If you want to create unit tests that are maintainable care must be taken to only add assertions to your test that 
    are of value for the test. Let me clarify this with an example: suppose you have a test for a calulation of an account balance. 
    There is no need to add any assertions to this test that will check whether the name of the bank-customer is still correct.
    This will only add complexity to your test making it more difficult to understand and, more importantly, more brittle against changes 
    in the code. If you want your code to easily survive refactorings and other code changes, make sure you limit your assertions and 
    test data setup to the scope of the test.
    
    To help you in writing assertions that only test what is important, we added some levels of leniency to the ReflectionAssert checks, which 
    we will cover more in-depth in the sections that follow.


*** Lenient order
~~~~~~~~~~~~~~~~~
    A first type of leniency you can specify is ignoring the order of elements in a collection or an array. It is often the case that when working with 
    lists, you are not interested in the order of the elements, only that they comply to certain criteria. For example, code for retrieving 
    all bankaccounts with a negative balance will typically return them in a list in a certain order that is unimportant for further processing.
    
    To implement this behavior, the <ReflectionAssert.assertRefEquals> method can be configured to ignore ordering by 
    supplying it with the <ReflectionComparatorMode.LENIENT_ORDER> comparator mode:

+-----+
List<Integer> myList = Arrays.asList(3, 2, 1);
assertRefEquals(Arrays.asList(1, 2, 3), myList, LENIENT_ORDER); 
+-----+

    The <ReflectionAssert> class also offers an assertion for which two leniency levels, lenient order and 
    ignore defaults (see below) are pre-set: <ReflectionAssert.assertLenEquals>. The above example can therefore be re-written as follows:
    
+-----+
List<Integer> myList = Arrays.asList(3, 2, 1);
assertLenEquals(Arrays.asList(1, 2, 3), myList); 
+-----+
    
    This len/ref thing is a general naming convention: assert<<Ref>>... is the version that is strict by default and for which you can 
    manually set the leniency levels, assert<<Len>>... is the version for which the lenient order and ignore defaults are pre-set. 
    

*** Ignoring defaults
~~~~~~~~~~~~~~~~~~~~~
    A second type of leniency is specified by the <ReflectionComparatorMode.IGNORE_DEFAULTS> mode. When this mode is set fields in the 
    left (expected) instance will only be compared with the corresponding fields in the right (actual) instance if they have a non 
    java default value, i.e. <null> or <0>. In other words, if you leave the value of a left-instance field to <null> or <0> it will not 
    be used in the comparison.
    
    As an example, suppose you have a user class with a first name, last name, street, ... field, but you only want to check that the 
    resulting user instance has a certain first name and street value, the other fields can be ignored:

+-----+
User actualUser   = new User("John", "Doe", new Address("First street", "12", "Brussels"));
User expectedUser = new User("John",  null, new Address("First street", null,       null));
assertLenEquals(expectedUser, actualUser);
+-----+

    You specify that you want to ignore a field by setting this value to null in the left (=expected) instance. 
    Right-instance fields that have default values will still be compared.
    
+-----+
assertLenEquals(null, "any");  // Succeeds
assertLenEquals("any", null);  // Fails
+-----+    


*** Lenient dates
~~~~~~~~~~~~~~~~~
    A third and final type of leniency is <ReflectionComparatorMode.LENIENT_DATES>. This will assert that date field values in both instance 
    are set or not set, but ignore the actual values of the date. E.g. a date from last year will equal the current date. 

+-----+
Date actualDate =   new Date(44444);
Date expectedDate = new Date();
assertRefEquals(expectedDate, actualDate, LENIENT_DATES); 
+-----+




** Property assertions
~~~~~~~~~~~~~~~~~~~~~~
    The <assertLenEquals> and <assertRefEquals> methods compare objects as a whole. ReflectionAssert also contains methods to compare 
    a certain field of two objects: <assertPropertyLenEquals> and <assertPropertyRefEquals>. The actual field that needs to be compared 
    is specified using the {{{http://www.ognl.org/}OGNL}} notation, in which the typical bean property notation, e.g. 
    field1.innerField, and more powerful notations can be used.
    
    Some examples of property comparisons are:

+-----+
assertPropertyLenEquals("id", 1, user);
assertPropertyLenEquals("address.street", "first street", user);
+-----+

    You can also supply collections as arguments. In that case the specified field will be taken of each element in the collection. This
    provides an easy way to for example check whether all users in a retrieved list have certain id: 

+-----+
assertPropertyLenEquals("id", Arrays.asList(1, 2, 3), users);
assertPropertyLenEquals("address.street", Arrays.asList("first street", "second street", "third street"), users);
+-----+

    There are again two versions of each method: an assertProperty<<Len>>Equals method and a assertProperty<<Ref>>Equals method. 
    The ref version will have no leniency specified by default but provides the option to specify leniency modes, the len version
    already has lenient order and ignore defaults set as fixed leniency modes.




* Testing with mock objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Unit tests should test code in isolation. Mock objects allow testing a component without having to care about other 
    components or services that it depends on. Unitils builds further on {{{http://www.easymock.org}EasyMock}} for its mock object testing 
    support. Unitils provides convenience functionality that greatly reduces the plumbing code that needs to be written when working with 
    mocks. This involves simplification of mock creation, argument matching and injection of mocks.
    
    If you don't have experience with EasyMock, first read {{{http://www.easymock.org/EasyMock2_2_Documentation.html}EasyMock 2.2's documentation}}, 
    before proceeding with this tutorial.


** Mock creation
~~~~~~~~~~~~~~~~
    Unitils makes sure that mock objects are injected into a unit test class before the execution of each test. Following example 
    shows a unit test for a method on a UserService that disables all inactive user accounts. All data access is delegated to a 
    UserDao service, which is replaced by a mock object.
    
+-----+
public void UserServiceTest extends UnitilsJUnit4 { 

	@Mock
	private UserDao mockUserDao;

	private UserService userService;

	@Test testDisableInActiveAccounts() {
    
    expect(mockUserDao.getAccountsNotAccessedAfter(null)).andReturn(accounts);
		mockUserDao.disableAccount(accounts.get(0));
		mockUserDao.disableAccount(accounts.get(1));
		replay();

		userService.disableInActiveAccounts();	
	}
} 
+-----+

    Mock creation and assignment to the test object's fields is performed before executing the test fixture (this is the setUp method in JUnit3, or the @BeforeMethod methods in TestNG)
   
    The mock objects created by Unitils by default use EasyMock's strict call expectations (i.e. the test fails when unexpected method calls occur) and lenient invocation order. You can
    change these default values either by specifying attributes on the @Mock annotation, e.g.:
   
+-----+
@Mock(returns = Returns.NICE, invocationOrder = InvocationOrder.STRICT)
private UserDao mockUserDao;
+-----+

    You can also change the default values for all unit tests in your project using the properties <EasyMockModule.Mock.InvocationOrder.default> and <EasyMockModule.Mock.Returns.default>. E.g.

+-----+
EasyMockModule.Mock.InvocationOrder.default=lenient
EasyMockModule.Mock.Returns.default=nice
+-----+
   
**   Reflection lenient argument matching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    The mocks that are supplied by Unitils differ from mocks objects that you get when directly using EasyMock. These mocks use a <LenientMocksControl>. 
    This control makes sure that by default, arguments specified in expectation clauses are matched using Unitils' <ReflectionComparator>. By default, this comparator uses the 
    leniency levels <IGNORE_DEFAULTS> and <LENIENT_ORDER>. E.g., in the above example, following expectation is set:
    
+-----+
mockUserDao.disableAccount(accounts.get(0));
+-----+

    When this method invocation is occured during test execution (after <replay()>), the actual account object will be compared with the expected one using reflection equality with 
    the leniency levels <IGNORE_DEFAULTS> and <LENIENT_ORDER>.
    
    Leniency levels also apply at top level. For example, when you look at following extract from the example above:
    
+-----+
expect(mockUserDao.getAccountsNotAccessedAfter(null)).andReturn(accounts);
+-----+

    The <null> parameter in this method call actually means that we don't care what argument is passed to this method. This provides a very convenient way of setting flexible expectations!

    The leniency levels that are used for argument matching can be configured for each individual mock. E.g., for using strict order, no ignoring of defaults but lenient date checking:

+-----+
@Mock(order = Order.STRICT, defaults = Defaults.STRICT, dates = Dates.LENIENT)
private UserDao mockUserDao;
+-----+

    The defaults can also be set project-wide, e.g. to do the same as above for the entire project:

+-----+
EasyMockModule.Mock.Order.default=strict
EasyMockModule.Mock.Dates.default=lenient
EasyMockModule.Mock.Defaults.default=strict
+-----+

    If you don't want to use reflection for lenient argument matching, you can also make Unitils inject regular EasyMock mocks into your test, using the RegularMock annotation.

+-----+
@RegularMock
private UserDao mockUserDao;
+-----+


   

** Mock injection
~~~~~~~~~~~~~~~~~
   Unitils provides services that simplify mock injection in various ways. Unitils' injection support is in the first place intended for 
   projects that use an IOC framework like Spring to wire up objects. E.g.

+-----+
  @Mock @Inject(property = "userDao")
  private UserDao mockUserDao;

  @TestedObject
  private UserService userService;
+-----+

  Before executing a test method in the above example, but after the test fixture, the mockUserDao will be injected into the userDao property of the userService.
  The value for the attribute property of @Inject can be an arbitrary OGNL expression. Getter / setter and field access may be mixed and private access is also supported.
  
  The target object for injection is by default the field that is annotated as TestedObject. Multiple fields may be annotated as TestedObject, in this case the object
  will be injected into every annotated field. If injection is not possible (e.g. a property in the OGNL expression doens't exist), the test fails.
  
  The target object can also specified explicitly, using the target attribute on the Inject annotation:
  
+-----+
  @Mock @Inject(target = "userService", property = "userDao")
  private UserDao mockUserDao;

  private UserService userService;
+-----+
  
  The injection module also supports automatically injecting objects into the target by type. E.g.
  
+-----+
  @Mock @AutoInject
  private UserDao mockUserDao;

  @TestedObject
  private UserService userService;
+-----+

  The mockUserDao will be injected into a property of userService with the type UserDao or a superclass or interface of UserDao. If more than one candidate target property exists, the most specific one
  is chosen. If no single most specific target property can be found, a UnitilsException is thrown and the test fails.
  
  The variant of the Inject and AutoInject annotation are foreseen, for injection into a static field or setter method. These are called InjectStatic and AutoInjectStatic, respectively.
  A common use of these annotations is to inject a mock into a singleton class.

*** Mock injection when using a Service Locator
~~~~~~~~~~~~~~~~~~~~~~~~~~~

  An AfterCreateMock annotation is foreseen, that allows intercepting a mock immediately after creation. The annotated method takes as parameters an Object (the mock), a String (the name of the field
  to which the mock is assigned) and a Class (the type of the mock object). This method could be implemented as follows:
  
+-----+

  @AfterCreateMock
  protected final void injectMock(Object mock, String name, Class type) {
     ServiceLocator.injectService(type, mock);
  }
  
+----+

  The method ServiceLocator.injectService make sure that when the ServiceLocator is requested for an implementation of UserDao, the mock is returned. This allows for a very simple way 
  of using mock object in combination with a ServiceLocator.

