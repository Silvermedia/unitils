 -----
 Documentation
 -----
 -----

Introduction
~~~~~~~~~~~~

* Overview
~~~~~~~~~~
    Unit testing should be easy and intuitively... at least in theory. Real-life projects
    typically span multiple layers, are data-driven and use middleware technologies such as EJBs and Hibernate.

    Unitils originated out of an attempt to get a more pragmatic view on unit testing that involves some
    typical unit testing frameworks such as DbUnit and EasyMock. It started as a set of guidelines and
    eventually resulted in an open source library containing utilities that facilitate the application of these guidelines.

    Currently Unitils offers follwing features:

    * <General testing utilities>

        * Equality assertion through reflection, with different options like ignoring Java default/null values and ignoring order of collections

    []

    * <Database testing utilities>

        * Automatic maintenance and constraints disabling of unit test databases

        * Simplify unit test database connection setup

        * Simplify insertion of test data with DBUnit

        * Simplify Hibernate session management for unit testing

        * Automatically test the mapping of Hibernate mapped objects with the database

    []

    * <Mock object utilities>

        * Simplify EasyMock mock object creation

        * Simplify mock object injection

        * EasyMock argument matching using reflection equality

    []
    
   
    This tutorial will show you by example what Unitils is about and how you can configure your project to make use of it's services.
    It is only an introduction to Unitils, more in-depth documentation can be found in the {{{javadoc.html}javadoc}} of the modules.
    The testing guidelines that are behind the features can be found on the {{{guidelines.html}guidelines page}}.


* Getting started
~~~~~~~~~~~~~~~~~    

** Configuration
~~~~~~~~~~~~~~~~
    As with many projects, Unitils needs some configuration of its services. By default, there are 3 levels 
    of configuration, each level overriding the settings of the previous one: 

    [[1]] <Unitils-defaults.properties>: default configuration that is shipped within the distribution of Unitils
    
    [[2]] <Unitils.properties>: can contain project-wide configuration
    
    [[3]] <Unitils-local.properties>: can contain user-specific configuration
    
    []

    The first file, Unitils-defaults.properties, contains default values and is packaged in the Unitils jar. There is no need to make changes 
    to this file, but it can be used as reference, since it contains all possible configuration settings for Unitils.
    
    The second, Unitils.properties, can override the defaults and is typically used to set values for configuration settings for all developers 
    on a project. For example if your project uses an oracle database, you can create a Unitils.properties file
    that overrideds the driver class name and url properties as follows:
    
+---------------------------------------------------------+
dataSource.driverClassName=oracle.jdbc.driver.OracleDriver
dataSource.url=jdbc:oracle:thin:@yourmachine:1521:YOUR_DB
+---------------------------------------------------------+
    
    The file is not required, but if you create one, it should be placed somewhere in the classpath of your project. 
    You can find a sample file that contains most commonly used configuration settings in following Unitils.properties template.
    
    The last file, Unitils-local.properties, is also optional and can contain settings that override the project settings and 
    define per user configuration. For example, if each user uses its own unit-test database schema, you can 
    create a Unitils-local.properties for each user that contains the corresponding schema, username and password:

+------------------------------------------+
dataSource.schemaName=test_john
dataSource.userName=john
dataSource.password=secret
+------------------------------------------+

    Each of these Unitils-local.properties files should be placed in the corresponding home folders of the user (<System.getProperty("user.home")>). 

    The name of the local file, Unitils-local.properties, is also defined by a property. This makes it possible to use different names for each 
    of the projects you are working on. For example, suppose you are working on a project named projectOne and want to start a new project 
    named projectTwo. Adding following property to the Unitils.properties of projetTwo will let Unitils use projectTwo-local.properties 
    as local properties file for the project:
    
+--------------------------------------------------------------+
Unitils.configuration.localFileName=projectTwo-local.properties
+--------------------------------------------------------------+    
    

** Making your test Unitils-enabled
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Unitils offers services for test classes. To let your test make use of these services, you first have to Unitils-enable your test.
    This can be done easily by (indirectly) extending from a Unitils base test-class. Currently there are base classes for the major test frameworks:
    
    * <<{{{http://www.junit.org/}JUnit3}}>>: org.unitils.UnitilsJUnit3
    
    * <<{{{http://www.junit.org/}JUnit4}}>>: org.unitils.UnitilsJUnit4
    
    * <<{{{http://testng.org/}TestNG}}>>: org.unitils.UnitilsTestNG
    
    []
    
    As an example, suppose you have a JUnit3 test that you want to Unitils-enable:
    
+------------------------------------------+
import org.unitils.UnitilsJUnit3;

public class MyTest extends UnitilsJUnit3 {
}
+------------------------------------------+

    Typically you would create your own test base class containing some utility behavior common for all your tests, e.g. datasource injection, and 
    then let this base class extend from one of the Unitils base classes.    
    
    For JUnit4 it is also possible to add a @RunWith annotation instead of extending from the base class:
    
+------------------------------------------+
import org.junit.runner.RunWith;
import org.unitils.UnitilsJUnit4TestClassRunner;

@RunWith(UnitilsJUnit4TestClassRunner.class)
public class MyTest {
}
+------------------------------------------+
    
    

** Module system
~~~~~~~~~~~~~~~~    
    Before starting with the examples, let's first take a look at some of the concepts used in Unitils and how the framwork functions under the hood.

    Unitils is structured as an easily extensible system of modules. Each of these modules offers some type of service to a test by listening to the 
    execution of the test and invoking the correct service behavior when needed.
   
[images/Unitils-modules.png] Unitils modules
   
   This mechanism provides a uniform way for providing extra services to your tests and offers a flexible way of adding services without having 
   to change the superclass of the test. Adding new services is as easy as adding a new module and making some changes to the unitils configuration.
   
   Currently, following modules are available in Unitils:
   
   * <DatabaseModule>: unit-test database maintenance and connection pooling
   
   * <DbUnitModule>: test data management using DBUnit
   
   * <HibernateModule>: Hibernate configuration support and automatic database mapping checking
   
   * <EasyMockModule>: support for creating mocks and lenient reflection argument matching
   
   * <InjectModule>: support for injecting (mock) objects into other objects

   * Planned: support for JPA. 




* Database testing
~~~~~~~~~~~~~~~~~~
    Unit tests for the database layer are extremely valuable in enterprise applications, but are often abandoned because of their complexity. 
    Unitils greatly reduces this complexity, making database testing simple and maintainable. The following sections describe the database 
    support by a number of simple examples. For an elaborate description of the guidelines, read the database testing guidelines.
 
** Managing test data with DbUnit
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Database tests should be run on a unit test database, having complete and fine grained control over the test data that is used. Unitils
    builds further on DBUnit for providing support for test data sets. Following code section provides a simple example of a database unit test with Unitils' DbUnit support.
    
    Let's say we have UserDAO with a simple findByName method for retrieving a user based on it's first and last name. The unit test looks as follows:
    
+-----+
    @DatabaseTest
    public void UserDAOTest extends UnitilsJUnit4 {
    
     	public void testFindByName {
         User johnDoe = userDao.findByName("doe", "john");
         assertEquals("jdoe", johnDoe.getUserName());
    	}
    	
    	public void testFindByMinimalAge {
    		List<User> min18 = userDao.findByMinimalAge(18);
    		assertEquals(1, min18.size());
    		assertEquals("jack", min18.get(0).getUserName());
    	}
    
    }
+-----+

    The class level data file UserDAOTest.xml is located in the same package as the test class:
    
+-----+
    <?xml version='1.0' encoding='UTF-8'?>
    <dataset>
	     <user userName="jdoe" name="doe" firstname="john" />
    </dataset>
+-----+

    The method testFindByMinimalAge has a specific data file named UserDAOTest.testFindByMinimalAge.xml:
    
+-----+
    <?xml version='1.0' encoding='UTF-8'?>
    <dataset>
	     <user userName="jack" age="18" />
	     <user userName="jim" age="17" />
    </dataset>
+-----+

    The annotation @DatabaseTest marks the test as being a database test, instructing Unitils to look for DBUnit datafiles to load. Unitils automatically looks
    for a data file names <className>.xml. All existing data in the tables specified in the dataset is deleted, and the data 
    in the datafile is inserted. DbUnit's FlatXMLDataSet is used as the file format.
    
    For methods needing very specific data, it may be a good idea to use a method level dataset. Unitils automatically looks for files named <className>.<methodName>.xml, such
    as the file UserDAOTest.testFindByMinimalAge.xml in the example.
    
    The datasets to use can also be specified explicitly using the annotation @DbUnitDataSet, like in the following example:
    
+-----+
    @DatabaseTest
    @DbUnitDataSet(fileName = "UserDAOTest_general.xml")
    public void UserDAOTest extends UnitilsJUnit4 {
    
     	public void testFindByName {
         User johnDoe = userDao.findByName("doe", "john");
         assertEquals("jdoe", johnDoe.getUserName());
    	}
    	
    	@DbUnitDataSet(fileName = "UserDAOTest_ages.xml")
    	public void testFindByMinimalAge {
    		List<User> min18 = userDao.findByMinimalAge(18);
    		assertEquals(1, min18.size());
    		assertEquals("jack", min18.get(0).getUserName());
    	}
    
    }
+-----+ 

    For checking the result of bulk update methods or stored procedures, Unitils offers support for result file checking. Suppose we have
    a data access method that gives all employees a 10% payraise as follows:

   Always keep in mind the following guidelines: 
   
   * Use small sets of test data, containing as few data as possible. In your data files, 
   only specifiy columns that are used in join columns or the where clause of the tested query.

   * Don't reuse data files too much. Make them test class and in some cases even test method specific. 
   Changing the data becomes very difficult when multiple tests are using the same data files.
  
   * Use a database schema per developer. This allows developers to insert test data and run tests without interfering each other.
   
   * Disable all foreign key and not null constraints on the test databases. This way, the data files need to contain no more
   data than absolutely necessary.
   
   To provide support with these 2 last features, Unitils offers automatic test database schema maintenance:

** Unit test database maintenance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    A powerful DBMaintainer is provided to automatically update each developer's database schema individually. Unitils' DBMaintainer
    will automatically check if database structure updates are available before running a database test, and apply them if necessary.
    
      

** Testing with Hibernate
~~~~~~~~~~~~~~~~~~~~~~~~~

*** Configuration
~~~~~~~~~~~~~~~~~

*** Testing the mapping
~~~~~~~~~~~~~~~~~~~~~~~

* Using reflection for assertion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Testing with mock objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~

** EasyMock mock creation
~~~~~~~~~~~~~~~~~~~~~~~~~

** Reflection lenient argument matching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

** Mock injection
~~~~~~~~~~~~~~~~~

*** Using a Service Locator
~~~~~~~~~~~~~~~~~~~~~~~~~~~

*** Using IOC
~~~~~~~~~~~~~

