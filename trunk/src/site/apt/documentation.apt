 -----
 Tutorial
 -----
 -----

Tutorial
~~~~~~~~
    Unit testing should be easy and intuitively... at least in theory. Real-life projects
    typically span multiple layers, are data-driven and use middleware technologies such as EJB and Hibernate.

    Unitils originated out of an attempt to get a more pragmatic view on unit testing that involves some
    typical unit testing frameworks such as DbUnit and EasyMock. It started as a set of guidelines and
    eventually resulted in an open source library containing utilities that facilitate the application of these guidelines.

    This tutorial will show you, using examples, what Unitils can do for your projects. It is merely an introduction to Unitils, 
    more in-depth documentation can be found in the {{{apidocs/index.html}javadoc}} of the modules. The testing guidelines that are 
    behind the features can be found on the {{{guidelines.html}guidelines page}}. If you want to learn how you can setup Unitils to 
    get started quickly, read the {{{cookbook.html}cookbook}}.




* Getting started
~~~~~~~~~~~~~~~~~

** {Configuration}
~~~~~~~~~~~~~~~~        
    As with many projects, Unitils needs some configuration of its services. By default, there are 3 levels
    of configuration, each level overriding the settings of the previous one:

    [[1]] <unitils-defaults.properties>: default configuration that is shipped with the distribution of Unitils

    [[2]] <unitils.properties>: can contain project-wide configuration

    [[3]] <unitils-local.properties>: can contain user-specific configuration

    []

    The first file, {{{unitils-default.properties} unitils-default.properties}}, contains default values and is packaged in the Unitils jar. 
    There is no need to make changes to this file, but it can be used as reference, since it contains all possible configuration settings for Unitils.

    The second, unitils.properties, can override the defaults and is typically used to set values for configuration settings for all developers
    on a project. For example if your project uses an oracle database, you can create a unitils.properties file
    that overrides the driver class name and url properties as follows:

+-----+
dataSource.driverClassName=oracle.jdbc.driver.OracleDriver
dataSource.url=jdbc:oracle:thin:@yourmachine:1521:YOUR_DB
+-----+

    The file is not required, but if you create one, it should be placed somewhere in the classpath of your project. To get you started, 
    you can find a sample file that contains most commonly used configuration settings in following {{{unitils.properties}unitils.properties}} template.

    The last file, unitils-local.properties, is also optional. It can contain settings that override the project settings and is used for
    defining per-user settings. For example, if each user uses its own unit-test database schema, you can create a unitils-local.properties for 
    each user that contains the corresponding username, password and database schema:

+-----+
dataSource.userName=john
dataSource.password=secret
database.schemaName=test_john
+-----+

    Each of these unitils-local.properties files should be placed in the corresponding home folders of the user's (<System.getProperty("user.home")>). 
    A typical local configuration can be found in following sample {{{unitils-local.properties}unitils-local.properties}} template.

    The name of the local file, unitils-local.properties, is also defined by a property. This makes it possible to use different names for each
    of the projects you are working on. For example, suppose you are working on a project named projectOne and want to start a new project
    named projectTwo. Adding following property to the unitils.properties of projetTwo will let Unitils use projectTwo-local.properties
    as local properties file for the project:

+-----+
unitils.configuration.localFileName=projectTwo-local.properties
+-----+




** {Making your test Unitils-enabled}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Unitils offers services to test classes through a test listener system. To enable Unitils to provide services to your tests, you first have to Unitils-enable them.
    This can be done easily by (indirectly) extending from a Unitils base test-class. Currently there are base classes for the major test frameworks:

    * <<{{{http://www.junit.org/}JUnit3}}>>: org.unitils.UnitilsJUnit3

    * <<{{{http://www.junit.org/}JUnit4}}>>: org.unitils.UnitilsJUnit4

    * <<{{{http://testng.org/}TestNG}}>>: org.unitils.UnitilsTestNG

    []

    As an example, suppose you have a JUnit3 test that you want to Unitils-enable:

+-----+
import org.unitils.UnitilsJUnit3;

public class MyTest extends UnitilsJUnit3 {
}
+-----+

    Typically you would create your own base test class containing some utility behavior common for all your tests, e.g. datasource injection, and
    then let this base class extend from one of the Unitils base classes.

    When you use JUnit4 you can also Unitils-enable a class by adding and @RunWith annotation instead of extending from the base class:

+-----+
import org.junit.runner.RunWith;
import org.unitils.UnitilsJUnit4TestClassRunner;

@RunWith(UnitilsJUnit4TestClassRunner.class)
public class MyTest {
}
+-----+

    Instead of extending from one of Unitils base classes you could also create a custom Unitils-enabled superclass by copying the source code of 
    the base class (e.g. <UnitilsJUnit3>) to the custom superclass. This superclass can then still extend from another class, e.g.
    from {{{http://www.springframework.org}Spring}}'s AbstractDependencyInjectionSpringContextTests which is already a subclass of JUnit3's 
    TestCase.
    




** {Module system}
~~~~~~~~~~~~~~~~
    Before starting with the examples, let's first take a look at some of the concepts used in Unitils and how it functions under the hood.

    Unitils is structured as an easily extendible system of modules. Each of these modules offers some type of service to a test by listening to the
    execution of the test and invoking the correct service behavior when needed. The base classes that Unitils provides (<UnitilsJUnit3>, 
    <UnitilsJUnit4>, <UnitilsTestNG>), couple the unit tests with the modules listening system.

[images/unitils-modules.png] Unitils modules

   This mechanism offers a uniform way for providing extra services to your tests and a flexible way of adding services without having
   to change the superclass of the test. Adding new services is as easy as adding a new module and registering this module in one of Unitils' configuration files.

   Currently, following modules are available in Unitils:

   * <DatabaseModule>: unit-test database maintenance and connection pooling

   * <DbUnitModule>: test data management using DBUnit

   * <HibernateModule>: Hibernate configuration support and automatic database mapping checking

   * <EasyMockModule>: support for creating mocks and lenient reflection argument matching

   * <InjectModule>: support for injecting (mock) objects into other objects
   
   * <SpringModule>: support for loading application contexts and retrieving and injecting Spring beans




* {Database testing}
~~~~~~~~~~~~~~~~~~
    Unit tests for the database layer can be extremely valuable when building enterprise applications, but are often abandoned because of 
    their complexity. Unitils greatly reduces this complexity, making database testing easy and maintainable. The following sections 
    describe the support that the <DatabaseModule>, <DbUnitModule> and <HibernateModule> have to offer for your database tests.



** {Managing test data with DbUnit}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Database tests should be run on a unit test database, having complete and fine grained control over the test data that is used. Unitils
    builds further on DBUnit for providing support for working with test data sets. 


*** {Loading test data sets}
~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Let's start with an example of a UserDAO with a simple findByName method for retrieving a user based on it's first and last 
    name. A typical unit test would look as follows:

+-----+
@DataSet
public void UserDAOTest extends UnitilsJUnit4 {

    @Test
    public void testFindByName {
        User johnDoe = userDao.findByName("doe", "john");
        assertEquals("jdoe", johnDoe.getUserName());
    }

    @Test
    public void testFindByMinimalAge {
        List<User> min18 = userDao.findByMinimalAge(18);
        assertEquals(1, min18.size());
        assertEquals("jack", min18.get(0).getUserName());
    }
}
+-----+

    The <@DataSet> annotation in the test instructs Unitils to look for DBUnit datafiles that need to be loaded for the test. Unitils 
    automatically looks for data set files that are in the same directory as the test class and have following name pattern:

    * <className>.xml - for a data set that is shared by all tests in the test class.
    
    * <className>.<methodName>.xml - for a data set that is specific for the test method with the same name 
    
    []
    
    When a method-specific data set is found, this is used for the test. Otherwise, Unitils will look for a class-level data set.
    
    Such a data set file should be in DbUnit's {{{http://www.dbunit.org/apidocs/org/dbunit/dataset/xml/FlatXmlDataSet.html} FlatXMLDataSet}} file 
    format and should contain all data needed for the test. All existing content of tables in the data set will first be deleted and 
    then all data of the data set will be inserted in the database. Tables that are not in the data set will not be cleared. You can explicity 
    clear a table by adding an empty table element, e.g, \<MY_TABLE /\>.    
        
    For the UserDAOTest we could for example create a class level data set file named <UserDAOTest.xml> and put it in the same directory as 
    the UserDAOTest class:
    
+-----+
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <user userName="jdoe" name="doe" firstname="john" />
</dataset>
+-----+

    This will clear the user table and insert a user record for John Doe. 
    
    Suppose the <testFindByMinimalAge()> method needs a specific data set instead of the class-level data set. You could create a file named 
    <UserDAOTest.testFindByMinimalAge.xml> and put that file in the same directory as the test class:

+-----+
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <user userName="jack" age="18" />
    <user userName="jim"  age="17" />
</dataset>
+-----+

    Method-level data sets should not be overused, since having more data files means you have to do more maintenance. You should first try 
    to reuse the data in the class level data set - in most cases a small set of test records can be reused for multiple tests. If this would 
    result in a a big and incoherent data set, maybe it's better to use a method specific one or to try to split the test in 2 separate tests, 
    each having its own data set.
    
    By setting the <@DataSet> annotation on class level a data set is loaded for every test in the class. If a data set should only be loaded for 
    some of the tests, you should remove the class level annotation and annotate the test methods instead. Datasets will then only be loaded 
    for the annotated tests. If your data set file does not comply to the naming conventions as described above, you can also specify a file name 
    explicitly by passing the name as an argument to the <@DataSet> annotation:

+-----+
@DataSet("UserDAOTest_general.xml")
public void UserDAOTest extends UnitilsJUnit4 {

    @Test
    public void testFindByName {
        User johnDoe = userDao.findByName("doe", "john");
        assertEquals("jdoe", johnDoe.getUserName());
    }

    @DataSet("UserDAOTest_ages.xml")
    public void testFindByMinimalAge {
        List<User> min18 = userDao.findByMinimalAge(18);
        assertEquals(1, min18.size());
        assertEquals("jack", min18.get(0).getUserName());
    }
}
+-----+


*** {Asserting test results}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Unitils also offers support for checking the contents of a database with a certain data set after a test was run. This can be useful for example when you want
    to check the result of a bulk update method or stored procedures. 

    Following example tests a method that disables all user accounts that haven't been used for an entire year:

+-----+
public void UserDAOTest extends UnitilsJUnit4 {

    @Test
    @ExpectedDataSet
    public void testInactivateOldAccounts {
        userDao.inactivateOldAccounts();
    }
}
+-----+

    Note that we have added the <@ExpectedDataSet> to the test method. This will instruct Unitils to look for a data set file named 
    <UserDAOTest.testInactivateOldAccounts-result.xml> and compare the contents of the database with the contents of the data set:

+-----+
<?xml version='1.0' encoding='UTF-8'?>
<dataset>
    <user userName="jack" active="true" />
    <user userName="jim"  active="false" />
</dataset>
+-----+

    For this datas et, it will check whether there are 2 different user records with corresponding values in the User table in the 
    database. Other records and other tables are not taken into account.

    As with the <@DataSet> annotation, a file name can explicitly be specified. If no name is specified, following naming pattern 
    will be used: <className>.<methodName>-result.xml
    
    The use of result data sets should be kept to a minimum. Adding new data sets means more maintenance. As an alternative, you should always 
    try to perform the same check in the test code (e.g. by using a method <findActiveUsers()>).


*** {Connecting to the test database}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    In the above examples we left out 1 important thing: where is the <DataSource> for connecting to the test database coming from and how
    can we let our DAO classes make use of this <DataSource>? 
    
    When the first database test in your test suite is run, Unitils will create a <DataSource> instance that will conect to your unit-test database
    using the settings defined in the properties. Subsequent database tests will reuse this same datasource instance. Before a test is set up, this 
    datasource instance is then injected into the test instance: if a field or setter method is annotated with <@TestDataSource>, Unitils will set 
    the DataSource into this field or call the method with the <DataSource> as parameter. 
    
    You then only have to provide some project specific code, that configures your DAO code to use this datasource. Typically all this is implemented 
    once in a project-specific superclass for all your database tests. A simple example of such a base class could be:
    
+-----+
public abstract void BaseDAOTest extends UnitilsJUnit4 {

    @TestDataSource
    private DataSource dataSource;
    
    @Before    
    public void initializeDao() {
        BaseDAO dao = getDaoUnderTest();
        dao.setDataSource(dataSource);
    }
    
    protected abstract BaseDAO getDaoUnderTest();
}
+-----+    

    The above example used annotations to get a reference to the datasource, another way of making your code use the Unitils <DataSource> is by using 
    an instance of <org.unitils.database.UnitilsDataSource>. This is a wrapper that delegates to the test datasource. Just create an instance
    using the default constructor and you are able to connect to the unit test database. This can be used in e.g. a datasource XML config file
    or programmatically as follows:
    
+-----+
    DataSource ds = new UnitilsDataSource();
    Connection conn = ds.getConnection();
    ...
+-----+



** {Unit test database maintenance}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    When writing database tests, keep in mind following guidelines:

    * Use small sets of test data, containing as few data as possible. In your data files, only specifiy columns 
      that are used in join columns or the where clause of the tested query.

    * Make data sets test class specific. Don't reuse data sets between different test classes, for example
      do not use 1 big domain data set for all your test classes. Doing so will make it very difficult 
      to make changes to your test data for 1 test without braking anything for another test. You are writing 
      a unit test and such a test should be independent of other tests. 
      
    * Don't use too many data sets. The more data sets you use, the more maintenance is needed. Try to reuse the testclass
      data set for all tests in that testclass. Only use method data sets if it makes your tests more understandable and clear.

    * Limit the use of expected result data sets. If you do use them, only include the tables and columns that are
      important for the test and leave out the rest.

    * Use a database schema per developer. This allows developers to insert test data and run tests without interfering with each other.

    * Disable all foreign key and not null constraints on the test databases. This way, the data files need to contain no more
      data than absolutely necessary.

    []
    
    Following section describes how Unitils provides support for these 2 last guidelines: automatic test database schema maintenance and constraints disabling.

    A powerful <DBMaintainer> is provided to automatically update each developer's individual database schema when needed. It will check whether 
    database structure updates are available and apply them if necessary.
    
    The database maintainer works as follows: a project should have a directory that contains all database scripts of the application. These are typically 
    created incrementally, e.g. a first script contains the creation of a USERS table and a later script contains a statement for adding a 
    column to that table. The database maintainer will monitor this directory and makes sure that all changes to scripts and all new scripts 
    are performed on each of the test database instances. 
    
    This system is very powerful when you work with a SCM system such as Subversion. Suppose some developer creates a script that changes a table definition. 
    The database maintainer will automatically make sure that the unit-test schema of this developer is updated with these new modifications. He can then work 
    on the DAOs and other code to make sure they function correctly to incorporate these changes. In the mean while, other developers, since nothing was 
    committed yet, did not receive any new scripts and are thus still working on the old database structure. At this moment the tests are still fine because 
    they are still using the old version of the code and corresponding test code. Eventually the developer commits the new script and his changes to the code in 
    Subversion. When another developer then performs an update, he will receive the new script together with the corresponding code changes. The next time a 
    unit-test is run the database maintainer will then automatically update their unit-test schemas using this new database script. As a result the unit-tests
    are run against an updated database schema and should all be successful.
    
    The directory in which the scripts are located can be indicated using the following property:
    
+-----+
dbMaintainer.fileScriptSource.scripts.location=/myproject/dbscripts
+-----+

    Multiple directories can be configured, separated by commas. Subdirectories are also scanned for script files. Unitils expects that all scripts 
    follow a certain naming pattern: they start with a version number, followed by an underscore and end with '.sql' (this is configurable). The example 
    below shows some typical names for scripts. Note that the leading zeroes in the example are not required, they are only added to make sure the scripts 
    are shown in proper sequence in a file explorer window.

+-----+
dbscripts/ 001_initial.sql
           002_tracking_updates.sql
           003_auditing_updates.sql
+-----+

    Suppose you add a new script, this time with version number 4: <004_create_user_admin_tables.sql>. The next time you execute a database test, 
    the database maintainer will notice that the database structure is no longer up to date. It will update the database schema incrementally by 
    executing all of the new scripts, in this case only <004_create_user_admin_tables.sql>. 
        
    The database maintainer will also notice if one of the existing database scripts was altered. For example suppose that the <002_tracking_updates.sql> 
    was changed. In that case, the database maintainer will first clear the database, thereby removing all tables and then recreate it 
    from scratch, starting again from the first script.
    
    For performance reasons, it's a good practice to work incrementally, each time adding new update files for small database updates. This makes sure updates 
    can be executed very quickly. If desired, you can then once in a while clean up the small update scripts and replace them with one large DDL script.
    If you database is small, you could of course also simply maintain one script and update it each time a database update is needed.
    
    By default the database maintainer will store the current version of a database schema in a <DB_VERSION> table. This way, it can determine whether
    the database is up to date or not. This table will automatically be created if it does not yet exist.

    Before doing an update, all data in the database is deleted. This is done to avoid errors executing update scripts that add not-null columns or foreign keys 
    to existing tables. Sometimes, you can have tables of which the content may not be deleted. E.g. a table that contains read-only data such as configuration 
    settings. To enable this, it is possible to specify a number of tables for which the data should be preserved. The database maintainer can also be configured to 
    preserve tables, sequences ... that are normally dropped when rebuilding the schema from scratch. 
    
+-----+
dbMaintainer.cleanDb.tablesToPreserve=CONFIG_TABLE, USER_TABLE  // will not be cleared (but still dropped)
dbMaintainer.clearDb.itemsToPreserve=SPECIAL_TABLE, MY_SEQUENCE // will not be dropped or cleared
+-----+
    
    The database maintainer does more than just update the schema structure. After each update, it performs following actions:

    * <Disable foreign key and not-null constraints>

    * <Update sequences to high value>

    * <Generate a DTD of the schema structure>

    []
    
    To be able to work with the smallest possible test data sets, all foreign key and not null constraints on the test database are disabled. This way
    you only need to add data that is of real value for your test. Because less data is specified in the data set, they are easier to write, indicate
    more clearly what is acuatlly being tested and, more importantly, they become much easier to maintain.
    
    All sequences and identity columns are updated to a sufficiently high initial value (1000 by default). This way, you can use fixed primary key values 
    when inserting test data, avoiding conflicts with id sequences.
    
    If you're using an IDE like Eclipse or IntelliJ, the generated DTD can help you create data sets more quickly and with less chances of writing errors.
    Just add a doctype declaration to your data set pointing to the generated DTD file and the IDE will offer you auto-completion and validation while
    you are editing the file. The generated DTD describes the structure of the database in DbUnit's 
    {{{http://www.dbunit.org/apidocs/org/dbunit/data set/xml/FlatXmlDataSet.html} FlatXMLDataSet}} format.
    
+-----+
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE dataset SYSTEM "../dtds/database.dtd">

<dataset>
    <user userName="jack" active="true" />
    <user userName="jim"  active="false" />
</dataset>
+-----+
        
    The database maintainer is highly configurable. You can swith on or off things like constraints disabling, disable from scratch updates... 
    Look at the file unitils-default.properties for more information! 
    
    Some functionality of the database maintainer, e.g. constraint disabling, uses DBMS specific functionality. This functionality will only run 
    properly when the correct dialect (oracle, mysql...) is configured. For example, suppose you want to use oracle, you should set following property:
    
+-----+
database.dialect=oracle
+-----+
        
    Currently there is support for following databases:
    
    * Oracle: Tested with version 9i
    
    * Hsqldb: Tested with version 1.8.0
    
    * MySQL: Tested with version 5.0

    []
 
 
*** {Testing functions, stored procedures, ...}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Enterprise applications typically contain application code that is stored and executed on the database, like functions and stored procedures. 
    It can often be a good idea to always have these code definitions applied to your test databases, to unit-test their correct hehaviour or for 
    integration testing.
    It is in most cases not possible to simply mix them with the regular database DDL definitions, because the syntax of stored procedures is 
    different: A ';' in a regular DDL statement indicates the end of a statement, while a stored procedure typically contains multiple SQL statements,
    and a ';' doesn't mean the end of a stored procedure.
    
    The database maintainer will execute all scripts in the configured location whenever one of these files is changed, or after updating the database structure.
    Before doing this, a service implementing the <DbCodeClearer> interface is called, doing some necessary cleanup first. For the moment, this service
    only drops database triggers and oracle types. In most cases it is not needed that the stored procedure definitions are cleared first, since their
    existing definition can be overwritten using <CREATE OR REPLACE>.
    
    The directory(ies) containing script files with triggers, functions and stored procedures can be configured as follows:
    
+-----+
dbMaintainer.fileScriptSource.code.location=/myproject/dbscripts/procedures
+-----+

    
    Multiple directories can be configured, separated by commas. Subdirectories are also scanned for script files. Since for database sources, the 
    sequence in which they are executed is in most cases not important, adding sequence numbers to the files is not required. If you do add sequence
    numbers, the scripts with numbers are executed first. For example, suppose we have following files:
    
+----+
databasecode/ 01_compileAll.sql
              dropAllInactiveUsers.sql
              collectivePayRaise.sql
							
+----+

    Unitils will first execute the non-indexed scripts. This will make sure the stored procedures in dropAllInactiveUsers.sql and collectivePayRaise.sql 
    are created in the database. Next, the indexed files are executed in proper sequence, which in this case will make sure the script 01_compileAll.sql 
    is executed that compiles all stored procedures in the database.
    
    Code script files can contain multiple function / stored procedure / ... definitions. The different definitions should be separated by a / sign
    that is put on a separates line, like follows:
    
+-----+
stored procedure definition 1
/
stored procedure definition 2
+-----+



** {Testing with Hibernate}
~~~~~~~~~~~~~~~~~~~~~~~~~
    An O/R mapping framework like Hibernate greatly simplifies the data access layer of an application. Even when using such a O/R mapping tool, unit 
    tests remain valuable. They can ensure the mapping of the Hibernate mapped classes is always in sync with the database and can be used for 
    easy and quick testing of HQL queries.

    A HQL method can be tested in exactly the same way as described above in {{{#Loading test data with DbUnit} Managing test data with DbUnit}}. 
    The <@ExpectedDataSet> annotation can also be used for checking the result of a test using a data set. To make sure that all database 
    updates were actually executed on the database, Unitils will flush all Hibernate sessions before checking the database state. 


*** {Loading Hibernate configurations}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    
    Unitils provides out-of-the box configuration support for Hibernate. You can obtain a <SessionFactory> that connects to the unit test database simply by
    annotating a field or method with the <@HibernateSessionFactory> annotation. This annotation can be parameterized with one or more Hibernate 
    configuration files that you want to have loaded. If you annotate a field or method with this annotation, the session factory will be 
    injected in this field or method. This is demonstrated in the following example:
    
+-----+
@HibernateSessionFactory({"hibernate.cfg.xml", "mapped-classes.cfg.xml"})
public class UserDaoTest extends UnitilsJUnit4 {
    
    @HibernateSessionFactory
    private SessionFactory sessionFactory;
    
    @HibernateSessionFactory
    private void setSessionFactory(SessionFactory sessionFactory) {
    }
}
+-----+

    This will create a Hibernate <Configuration> and load the <hibernate.cfg.xml> followed by the <mapped-class.cfg.xml> configuration files. The
    <Configuration> instance is then used to create a <SessionFactory> which is injected into the annotated field and setter method of the test.
    
    Any Hibernate configuration files that are specified in superclasses are inherited by subclasses. For instance, you can specify a general Hibernate
    configuration file in the superclass and a test specific configuration file in a subclass:
    
+-----+
@HibernateSessionFactory("hibernate.cfg.xml")
public class BaseDaoTest extends UnitilsJUnit4 {
}

@HibernateSessionFactory("user-mapped-classes.cfg.xml")
public class UserDaoTest extends BaseDaoTest {
     
    @HibernateSessionFactory
    private SessionFactory sessionFactory;
}
+-----+
    
    Programmatic configuration can also be performed by annotating a method with <@HibernateSessionFactory> that optionally takes a 
    <Configuration> object as parameter and returns a <SessionFactory> instance. Unitils will call this method passing the Hibernate configuration 
    as an argument. Any Hibernate configuration files that were specified at the class level in the same class or a superclass, will already be added
    to the <Configuration> object before it is passed into the method.
    
+-----+
@HibernateSessionFactory
protected SessionFactory createSessionFactory(Configuration configuration) {
    ...
}   
+-----+
    

*** {Hibernate Session management}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Typically, a project contains a base DAO class that contains a reference to the Hibernate <SessionFactory>, and opens <Session>s on it. It depends 
    on the configuration of the project when these sessions are closed. It can be done explicitly at the end of every DAO method, automatically
    behind the screens on transaction commit, or you could make use of sessions that span multiple transactions. You could use <SessionFactory.openSession()>
    and <Session.close()> methods to open and close sessions, or you could make use of <SessionFactory.getCurrentSession()> and rely on an implementation
    of Hibernate's <CurrentSessionContext> interface to handle session opening and closing for you.
    
    Whatever strategy you use, Unitils will make sure that after every unit test, any sessions that are still open are automatically closed, whether you use
    <SessionFactory.openSession()> or <SessionFactory.getCurrentSession()> to obtain a <Session>.
    
    Unitils also provides an implementation of Hibernate's <CurrentSessionContext>, <SimpleCurrentSessionContext> and adds this to the Hibernate configuration. 
    This enables you to use <SessionFactory.getCurrentSession()> in your tested code without having to do any configuration yourself. This implementation will
    make sure that a new <Session> is created the first time you call <SessionFactory.getCurrentSession()> in a test. For the duration of the test, the same
    instance of <Session> will be used. The <Session> is automatically closed after the test has finished.
    

*** {Testing the mapping}
~~~~~~~~~~~~~~~~~~~~~~~~
    Unitils is shipped with a ready-to-use unit test that verifies whether the mapping of all your mapped classes is consistent with the database. This
    test is not automatically executed; you should write a unit test that looks like the following:

+-----+
@HibernateSessionFactory("hibernate.cfg.xml")
public class HibernateMappingTest extends UnitilsJUnit4 {

    @Test
    public void testMappingToDatabase() {
        HibernateUnitils.assertMappingWithDatabaseConsistent();
    }
}
+-----+

    The method <HibernateUnitils.assertMappingWithDatabaseConsistent()> checks if any updates are required to the database to make it consistent with the 
    Hibernate mapping. If yes, the test fails and the DDL statements that should be issued to the database that will make the mapping consistent are shown 
    in the error message. E.g.
    
+-----+
Found mismatches between Java objects and database tables. Applying following DDL statements to the database should resolve the problem:
alter table PERSON add column lastName varchar(255);
alter table PRODUCT add column barCode varchar(255);
+-----+




* {Using reflection for assertion}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


** Reflection versus equals()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    A typical unit test contains a part in which it compares test result values with expected values. Unitils offers some
    assertion utilities to help you with this. 
    
    Let's start with an example of comparing 2 User instances having an id, a first and a last name:

+-----+    
public class User {

    private long id;
    private String first;
    private String last;


    public User(long id, String first, String last) {
        this.id = id;
        this.first = first;
        this.last = last;
    }
}

User user1 = new User(1, "John", "Doe");
User user2 = new User(1, "John", "Doe");
assertEquals(user1, user2);
+-----+

    You would expect that this assertion would be successful since both instances contain the same values. This is however 
    not the case, if User does not override the equals() method. Checking equals of 2 User instances is in that case the same
    as checking whether both instances are the same. In other words, the assertEquals actually results in user1 == user2 
    being tested causing the assertion to fail.
    
    Suppose you would implement the equals method as follows:
    
+-----+    
public boolean equals(Object object) {
    if (object instanceof User) {
        return id == ((User) object).id;
    }
    return false;
}
+-----+    

    This is a totally reasonable implementation for your application logic, stating that 2 user instances are referring to 
    the same user when they have the same id. However, this method is not useful in your unit tests. Testing whether 2 objects
    are equal is now reduced to the test whether they have the same id:
    
+-----+        
User user1 = new User(1, "John", "Doe");
User user2 = new User(1, "Jane", "Smith");
assertEquals(user1, user2);
+-----+

    This assertion will be successful, which is probably not what you want. Best is to avoid using equals() altogether 
    when comparing objects (except of course for objects with value semantics such as java.lang.String, ...). 
    One approach can be to do the comparison of each of the properties one by one:    
    
+-----+        
User user1 = new User(1, "John", "Doe");
User user2 = new User(1, "John", "Doe");
assertEquals(user1.getId(), user2.getId());
assertEquals(user1.getFirst(), user2.getFirst());
assertEquals(user1.getLast(), user2.getLast());
+-----+
    
    Unitils offers utilities that help you perform these checks more easily, through reflection. Using <ReflectionAssert.assertRefEquals>,
    the above example could be re-written as follows:
    
+-----+
User user1 = new User(1, "John", "Doe");
User user2 = new User(1, "John", "Doe");
assertRefEquals(user1, user2);    
+-----+

    This assertion loops over all fields in both objects and compares their values using reflection. For the above example, it will
    first compare both <id> field values, next both <first> field values and finally both <last> fields values. 
    
    If a field value itself is also an object, it will recursively be compared field by field using reflection. The same is true for 
    collections, maps and arrays. Their elements will be traversed and recusively be compared using reflection. If a value is a primitive 
    type (int, long, ...) or one of the primitive wrapper types (Integer, Long, ...) it will be compared by value (using ==). 
    As a result, following assertions, for example, will be successful:

+-----+
assertRefEquals(1, 1L); 

List<Double> myList = new ArrayList<Double>();
myList.add(1.0);
myList.add(2.0);
assertRefEquals(Arrays.asList(1, 2), myList); 
+-----+




** Lenient assertions
~~~~~~~~~~~~~~~~~~~~~
    If you want to create unit tests that are maintainable, care must be taken to only add assertions to your test that 
    are of value for the test. Let me clarify this with an example: suppose you have a test for a calulation of an account balance. 
    There is no need to add any assertions to this test that will check whether the name of the bank-customer is still correct.
    This will only add complexity to your test making it more difficult to understand and, more importantly, more brittle against changes 
    to the code. If you want your test code to easily survive refactorings and other code changes, make sure you limit your assertions and 
    test data setup to the scope of the test.
    
    To help you in writing assertions that only test what is important, we added some levels of leniency to the ReflectionAssert checks, which 
    we will cover more in-depth in the sections that follow.


*** Lenient order
~~~~~~~~~~~~~~~~~
    A first type of leniency you can specify is ignoring the order of elements in a collection or an array. It is often the case that when working with 
    lists, you are not interested in the order of the elements, only that they comply to certain criteria. For example, code for retrieving 
    all bank-accounts with a negative balance will typically return them in a list in a certain order, which is unimportant for further processing.
    
    To implement this behavior, the <ReflectionAssert.assertRefEquals> method can be configured to ignore ordering by 
    supplying it with the <ReflectionComparatorMode.LENIENT_ORDER> comparator mode:

+-----+
List<Integer> myList = Arrays.asList(3, 2, 1);
assertRefEquals(Arrays.asList(1, 2, 3), myList, LENIENT_ORDER); 
+-----+
    

*** Ignoring defaults
~~~~~~~~~~~~~~~~~~~~~
    A second type of leniency is specified by the <ReflectionComparatorMode.IGNORE_DEFAULTS> mode. When this mode is set, fields in the 
    left (expected) instance will only be compared with the corresponding fields in the right (actual) instance if they have a non 
    java default value, i.e. <null> or <0>. In other words, if you leave the value of a left-instance field to <null> or <0> it will not 
    be used in the comparison.
    
    As an example, suppose you have a user class with a first name, last name, street, ... field, but you only want to check that the 
    resulting user instance has a certain first name and street value, the other fields can be ignored:

+-----+
User actualUser   = new User("John", "Doe", new Address("First street", "12", "Brussels"));
User expectedUser = new User("John",  null, new Address("First street", null,       null));
assertLenEquals(expectedUser, actualUser);
+-----+

    You specify that you want to ignore a field by setting this value to null in the left (=expected) instance. 
    Right-instance fields that have default values will still be compared.
    
+-----+
assertRefEquals(null, "any", IGNORE_DEFAULTS);  // Succeeds
assertRefEquals("any", null, IGNORE_DEFAULTS);  // Fails
+-----+    


*** Lenient dates
~~~~~~~~~~~~~~~~~
    A third and final type of leniency is <ReflectionComparatorMode.LENIENT_DATES>. This will assert that date field values in both instances 
    are set or both equal to null, the actual values of the dates are ignored. E.g. a date from last year will equal the current date. This type 
    of leniency can be useful e.g. when you want to do a strict comparison of objects (without using the <ReflectionComparatorMode.IGNORE_DEFAULTS> mode), but
    when these objects have a createOn and lastModifiedOn fields that you want to ignore.

+-----+
Date actualDate =   new Date(44444);
Date expectedDate = new Date();
assertRefEquals(expectedDate, actualDate, LENIENT_DATES); 
+-----+


*** assertLenEquals
~~~~~~~~~~~~~~~~~~~
    The <ReflectionAssert> class also offers an assertion for which two of the leniency levels, lenient order and 
    ignore defaults are pre-set: <ReflectionAssert.assertLenEquals>. The above examples can therefore be re-written as follows:
    
+-----+
List<Integer> myList = Arrays.asList(3, 2, 1);
assertLenEquals(Arrays.asList(1, 2, 3), myList); 

assertLenEquals(null, "any");  // Succeeds
assertLenEquals("any", null);  // Fails
+-----+
    
    This len/ref thing is a general naming convention: assert<<Ref>>... is the version that is strict by default and for which you can 
    manually set the leniency levels, assert<<Len>>... is the version for which the lenient order and ignore defaults are pre-set. 
    
        

** Property assertions
~~~~~~~~~~~~~~~~~~~~~~
    The <assertLenEquals> and <assertRefEquals> methods compare objects as a whole. ReflectionAssert also contains methods to compare 
    a specific property of two objects: <assertPropertyLenEquals> and <assertPropertyRefEquals>. The actual field that needs to be compared 
    is specified using the {{{http://www.ognl.org/}OGNL}} notation, in which the typical bean property notation, e.g. 
    field1.innerField, and more powerful notations can be used.
    
    Some examples of property comparisons are:

+-----+
assertPropertyLenEquals("id", 1, user);
assertPropertyLenEquals("address.street", "First street", user);
+-----+

    You can also supply collections as arguments for this method. In that case the specified field will be compared on each element in the collection. This
    provides an easy way to for example check whether all users in a retrieved list have certain id: 

+-----+
assertPropertyLenEquals("id", Arrays.asList(1, 2, 3), users);
assertPropertyLenEquals("address.street", Arrays.asList("First street", "Second street", "Third street"), users);
+-----+

    Again there are two versions of each method: an assertProperty<<Len>>Equals method and a assertProperty<<Ref>>Equals method. 
    The ref version will have no leniency specified by default but provides the option to specify leniency modes, the len version
    already has lenient order and ignore defaults set as fixed leniency modes.





* Testing with mock objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Unit tests should test code in isolation. Mock objects allow testing a piece of code without having to care about other 
    parts or services that it depends on. Unitils builds further on {{{http://www.easymock.org}EasyMock}} for its mock object testing 
    support. Unitils provides convenience functionality that  reduces the plumbing code that needs to be written when working with 
    mocks. This involves simplification of mock creation, argument matching and injection of mocks.
    
    If you don't have experience with EasyMock, first read {{{http://www.easymock.org/EasyMock2_2_Documentation.html}EasyMock 2.2's documentation}}, 
    before proceeding with this tutorial.


** Mock creation
~~~~~~~~~~~~~~~~
    Unitils makes sure that mock objects are injected into a unit test class before the execution of each test. Following example 
    shows a unit test for a method on a UserService that disables all inactive user accounts:
    
+-----+
public void UserServiceTest extends UnitilsJUnit4 { 

    @Mock
    private UserDao mockUserDao;

    private UserService userService;

    @Test 
    testDisableInActiveAccounts() {
    
        expect(mockUserDao.getAccountsNotAccessedAfter(null)).andReturn(accounts);
        mockUserDao.disableAccount(accounts.get(0));
        mockUserDao.disableAccount(accounts.get(1));
        replay();

        userService.disableInActiveAccounts();	
    }
} 
+-----+

    In the example all data access is delegated to a UserDao service, which is replaced by a mock object. This mock is created automatically by Unitils. If you 
    annotate a field with the <@Mock> annotation, Unitils will create a mock of the same type as the field and inject the instance into that field. This mock creation 
    and assignment is performed before executing the test fixture (this is the setUp method in JUnit3, or the @BeforeMethod methods in TestNG). This way
    you can use the mock instance during the setup, for example, to make sure your code uses it during the test. Later-on we will show you
    how Unitils can help you perform this mock injection.
   
    The mock objects created by Unitils by default use EasyMock's strict call expectations (i.e. the test fails when unexpected method calls occur) and lenient 
    invocation order. You can change these default values by specifying attributes on the @Mock annotation, e.g.:
   
+-----+
@Mock(returns = Calls.LENIENT, invocationOrder = InvocationOrder.STRICT)
private UserDao mockUserDao;
+-----+

    You can also change the default values for all <@Mock> annotations using following configuration settings:

+-----+
EasyMockModule.Mock.Calls.default=lenient
EasyMockModule.Mock.InvocationOrder.default=strict
+-----+
   
   
   
**   Reflection lenient argument matching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    The mocks that are supplied by Unitils are slightly different from mocks objects that you get when directly using EasyMock: a <LenientMocksControl> is used 
    for these mocks. If you want Unitils to create a normal EasyMock mock, the <@RegularMock> annotation can be used instead.
    
    The <LenientMocksControl> control will make sure that arguments specified in method calls are matched using reflection. The arguments of the
    expected and actual method calls are compared in the same way as we saw in the {{{#Using reflection for assertion}Using reflection for assertion}} section. 
    By default, it will use the ignore defaults and lenient order leniency levels. E.g., following expectation and actual method calls will match:
    
+-----+
expected: dao.findById(0);
actual:   dao.findById(99999);

List<Integer> userIds = new ArrayList<Integer>();
userIds.add(3);
userIds.add(2);
userIds.add(1);
expected: dao.deleteById(Arrays.asList(1,2,3));
actual:   dao.deleteById(userIds);

expected: dao.update(0,    new User(null,   "Doe"));
actual:   dao.update(9999, new User("John", "Doe"));
+-----+

    As you can see, the leniency levels not only apply to objects and their fields but also apply to the argurments themselves. For example, take a look at following expectation:
    
+-----+
expect(mockUserDao.getAccountsNotAccessedAfter(null)).andReturn(accounts);
+-----+

    The <null> parameter in this method call actually means that we don't care what argument is passed to this method. This provides a very convenient way of setting flexible 
    expectations! There is no need to specify <anyInt>, <notNull> ... argument matchers for each of the arguments anymore.

    By default, lenient order and ignore defaults are used as leniency levels. If you want to change this, you can specify wich levels to use by setting attributes 
    on the <@Mock> annotation:

+-----+
@Mock(order = Order.STRICT, defaults = Defaults.STRICT, dates = Dates.LENIENT)
private UserDao mockUserDao;
+-----+

    The levels can also be set project-wide, for all mocks at once, by changing the defaults in the configuration settings. E.g. to do the same as above for the 
    entire project you could set following properties:

+-----+
EasyMockModule.Mock.Order.default=strict
EasyMockModule.Mock.Dates.default=lenient
EasyMockModule.Mock.Defaults.default=strict
+-----+

    If you don't want to use reflection for lenient argument matching, you can also make Unitils inject regular EasyMock mocks into your test, using the RegularMock annotation.

+-----+
@RegularMock
private UserDao mockUserDao;
+-----+




** Mock injection
~~~~~~~~~~~~~~~~~
    Unitils provides services that simplify mock injection in various ways. Following example shows how a 
    UserDao mock is created and injected in the the userService:

+-----+
@Mock @InjectInto(property = "userDao")
private UserDao mockUserDao;

@TestedObject
private UserService userService;
+-----+

    Before executing a test method in the above example, but after the test fixture, the <@Inject> annotation will cause the 
    mockUserDao to be injected into the userDao property of the userService. The value for the attribute property of @Inject can 
    be an arbitrary {{{http://www.ognl.org/}OGNL}} expression. Getter / setter and field access may be mixed and private access 
    is also supported.
  
    The target object for injection is by default the field that is annotated as TestedObject. Multiple fields may be annotated as TestedObject, 
    in this case the object will be injected into every annotated field. If injection is not possible (e.g. a property in the OGNL 
    expression doens't exist), the test fails.
  
    The target object can also specified explicitly, using the target attribute on the Inject annotation:
  
+-----+
@Mock @InjectInto(target = "userService", property = "userDao")
private UserDao mockUserDao;

private UserService userService;
+-----+
  
    The previous example showed how you can explicitly inject mocks by specifying the name of the target property. Unitils also 
    supports injecting objects into the target automatically by type. E.g.
  
+-----+
@Mock @InjectIntoByType
private UserDao mockUserDao;

@TestedObject
private UserService userService;
+-----+

    The mockUserDao will be injected into a property of userService with the type UserDao or a superclass or interface of UserDao. 
    If more than one candidate target property exists, the most specific one is chosen. If no single most specific target property can 
    be found, a UnitilsException is thrown and the test fails.
  
    There are also a variant of the <@Inject> and <@AutoInject> annotations provided, for injection into static fields or setter methods. 
    These are called <@InjectStatic> and <@AutoInjectStatic>, respectively. A common use of these annotations is to inject a mock 
    into a singleton class.




*** Mock injection when using a Service Locator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    The above way of injecting mocks is very powerful and easy, but sometimes applications are not coded in such a way that makes this possible. 
    It could be for example, that an application uses a service locator instead of the typical {{{http://www.springframework.org}Spring}}
    way of providing a setter and a field for your services, and so there nothing to inject the mock into. 
    
    To resolve this, an <@AfterCreateMock> annotation is provided that allows intercepting a mock immediately after creation. The annotated method 
    takes as parameters an Object (the mock), a String (the name of the field to which the mock is assigned) and a Class 
    (the type of the mock object). The mock instance can then be used to for example register the mock in the service locator. 
    For example, this method could be implemented as follows:
  
+-----+
@AfterCreateMock
void injectMock(Object mock, String name, Class type) {
    ServiceLocator.injectService(type, mock);
}
+----+

    The method ServiceLocator.injectService make sure that when the ServiceLocator is requested for an implementation of UserDao, 
    the mock is returned. This allows for a very simple way of using mock object in combination with such a service locator.





* Integration with Spring
~~~~~~~~~~~~~~~~~~~~~~~~~
    Unitils also offers features for unit testing when working with {{{http://www.springframework.org}Spring}}. One of the basic principles 
    of Spring is that your objects are designed in such way that they are easily testable without Spring or any other container. For integration 
    testing however, it can be useful to work with object structures that are wired by the Spring container. 
    
    The features Unitils offers for Spring are:
    
    * Management of <ApplicationContext> configuration
    
    * Simple injection of Spring beans in unit tests
    
    * Enable testing DAO's that make use of a Hibernate <SessionFactory> configured in Spring




** ApplicationContext configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    In order to test Spring-wired beans, you need an <ApplicationContext> in your tests. Typically, your application is configured by multiple
    Spring configuration files, and you need only one or a few for your test. Unitils offers a very simple but powerful way of specifying the
    config files that need to be loaded. The mechanism is analoguous to the way in which you can configure your Hibernate <SessionFactory>.
    
    A <@SpringApplicationContext> annotation can be put at class level or on a field or setter method. You can specify config files to be loaded 
    on either level. Superclasses will be scanned for the presence of class-level <@SpringApplicationContext> annotations. If present, the 
    configuration files that are found are loaded before loading the config files specified on the annotations of the current class. 
    For example:
    
+-----+
@SpringApplicationContext("spring-beans.xml","extra-spring-beans.xml")
public class UserServiceTest extends UnitilsJUnit4 {

     @SpringApplicationContext
     private ApplicationContext applicationContext;

}
+-----+

     This example will create a new <ApplicationContext> containing the files <spring-beans.xml> and <extra-spring-beans.xml>, and inject it into the 
     annotated field. The same effect can be obtained with the following:
     
+-----+
@SpringApplicationContext("spring-beans.xml")
public class BaseServiceTest extends UnitilsJUnit4 {

}

@SpringApplicationContext("extra-spring-beans.xml")
public class UserServiceTest extends BaseServiceTest {

     @SpringApplicationContext
     private ApplicationContext applicationContext;     

}
+-----+

     If you have multiple tests making use of the same configuration, it is advisory to make them extend a common superclass on which this configuration
     is specified at class level. This will make sure the <ApplicationContext> is only created once when running all of these tests in a suite.
     
     Programmatic configuration is also possible by annotating a method that takes a <List\<String\>> as parameter and returns an ApplicationContext.
     The parameter consists of the names of all configuration files specified using a <@SpringApplicationContext> annotation on the level of the class
     and/or its superclasses. The ApplicationContext that is returned should be a subclass of <ConfigurableApplicationContext>, and the refresh() method
     should not be invoked yet. This can be achieved by invoking a constructor with the value <false> for the refresh boolean parameter. This reason for 
     this is that Unitils needs to be able to add one or more BeanPostProcessors to the <ApplicationContext> before the <refresh()> method is called, which
     processes the configuration files and instantiates the singleton beans. A valid implementation could be the following:
     
+-----+
@SpringApplicationContext
public ConfigurableApplicationContext createApplicationContext(List<String> locations) {
     return new ClassPathXmlApplicationContext(Arrays.asList("spring-beans.xml","extra-spring-beans.xml"), false);
}
+-----+
    



** Injection of Spring beans
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     Once you've configured an ApplicationContext, you can in a very simple way make Unitils inject Spring beans in fields or setters of your test object. 
     This can be achieved using one of the annotations <@SpringBean>, <@SpringBeanByType> or <@SpringBeanByName>. When using <@SpringBean>, you have to 
     explicitly specify the  name of the bean in the ApplicationContext. E.g.:
     
+-----+
@SpringBean("userService")
private UserService userService;
+-----+

     The same effect can be reached using <@SpringBeanByName>, provided that the property name of the target field or setter is the same as the name of the 
     bean in the ApplicationContext:
     
+-----+
@SpringBeanByType
public void setUserService(UserService userService) {
	   this.userService = userService;
}
+-----+

     When using <@SpringBeanByType>, the ApplicationContext is queried for a bean having a type assignable to the type of the target field or setter. If 
     no such bean exists or if more than one is found, a <UnitilsException> is thrown. In the following example, Unitils will look in the ApplicationContext 
     for a bean of type UserService or a subtype.
     
+------+
@SpringBeanByType
public void setUserService(UserService userService) {
	   this.userService = userService;
}
+-----+
