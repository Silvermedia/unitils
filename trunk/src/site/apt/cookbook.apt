 -----
 Cookbook
 -----
 -----

Cookbook
~~~~~~~~

  This page will guide you step-by-step through the process of getting Unitils properly configured in your own software project. This is only the typical configuration. 
  There are a lot more configuration options in Unitils. A complete documented reference of all configuration options can be found in the source code in unitils-default.properties.
  For more information about Unitils' system of configuration files, read the documentation.
   
* Enable Unitils' assertion utils (ReflectionAssert), EasyMock and injection support
~~~~~~~~
  
  To be able to use these features, it is sufficient to add the unitils jar to your project's classpath.
  
  
* Enable support for database tests
~~~~~~~~
  
  To enable database testing as foreseen in Unitils, you should start by setting up a unit test database for every developer in your team. In our typical configuration shown below,
  we assume that for every developer, a separate test database schema was created on the same database instance.
  
  Create a file named unitils.properties and make it available in the root of your classpath. It should contain following properties:
  
+------+
# Name or path of the user specific properties file. This file should contain the necessary parameters to connect to the
# developer's own unit test schema. It is recommended to override the name of this file in the project specific properties
# file, to include the name of the project. The system will try to find this file in the classpath, the user home folder
# (recommended) or the local filesystem.
unitils.configuration.localFileName=unitils-<myproject>-local.properties

# Properties for the PropertiesDataSourceFactory
dataSource.driverClassName=<my driver classname>
dataSource.url=<my database connection url>

# This property specifies the underlying DBMS implementation. Supported values are 'oracle', 'db2', 'mysql' and 'hsqldb'.
# The value of this property defines which vendor specific implementations of ConstraintsDisabler, SequenceUpdater and
# DbClearer are chosen.
database.dialect=<my databasa dialect>
+------+

  Next, create a file unitils-<myproject>-local.properties on your local filesystem and fill in the path of this file as value for the property 'unitils.configuration.localFileName'.
  It's recommended to store this file in your user home directory; this allows specifying the filename in a Operation System independent way.
  
  unitils-<myproject>-local.properties contains following properties:

+------+
dataSource.schemaName=<developers database schema name>
dataSource.userName=<developers database login username>
dataSource.password=<developers database login password>
+------+

* Enable automatic developers' database maintenance
~~~~~~~~
  
  To enable automatic maintenance of the developers' test databases, start with adding a database scripts folder to your source control system, in which you add all your database schema update scripts.
  
  Next, add following properties to unitils.properties:
  
+------+
# If set to true, the DBMaintainer will be used to update the unit test database schema. This is done once for each
# test run, before the execution of the first class annotated with @DatabaseTest, if any.
updateDataBaseSchema.enabled=true

# Directory in which the database update scripts are located.
dbMaintainer.fileScriptSource.dir=<Path to your database update script files>

# DbUnit database DTD file path
dtdGenerator.dtd.filename=<Path to your database DTD>

# Comma separated list of table names. The tables in question will not be cleaned by the DBCleaner. Tables like these
# typically contain rather static, read only or type data. The database version table, indicated by the property
# dbMaintainer.dbVersionSource.tableName, is preserved automatically, and doesn't have to be included in this list.
# The tables in the list specified by dbMaintainer.cleardb.itemsToPreserve are also left untouched.
# Note that the DBClearer doesn't take this list into account. So when fromScratch is enabled
# (dbMaintainer.fromScratch.enabled=true), these tables will be removed anyway. If you want some tables/views/sequences/...
# to be preserved when creating the database from scratch, add them to dbMaintainer.cleardb.itemsToPreserve
dbMaintainer.cleandb.tablesToPreserve=<Optional list of tables from which the data should be preserved>

# Comma separated list of database items. These can be tables / views / sequences or trigger names. These items will not
# be cleared by the DBClearer when updating the database from scratch (dbMaintainer.fromScratch.enabled=true). The tables
# in this list will also not be cleaned by the DBCleaner.
dbMaintainer.cleardb.itemsToPreserve=<Optional list of database items that shouldn't be dropped>
+------+

* Enable Hibernate support
~~~~~~

  Unitils provides out-of-the box configuration support for Hibernate. Make sure you properly configure Unitils' database support first, and then correctly
  override the property HibernateModule.hibernate.configfiles in unitils.properties. E.g.

+-----+
# Name of hibernate config files for testing purposes. Should be in classpath.
HibernateModule.hibernate.configfiles=
              hibernate-general.cfg.xml,hibernate-unittest.cfg.xml
+-----+

  It is a good practice to split your Hibernate configuration in two parts: One config files containing shared configuration, such as the database dialect
  and the mapped classes. A second one contains configuration that is specifically for unit testing. TODO example files.

  We advise you to write a superclass that is used as base class for all Hibernate tests. This superclass looks like the following:

+-----+
@HibernateTest
public abstract class BaseHibernateTest extends UnitilsJUnit3 {

  @HibernateConfiguration
  public void configureHibernate(Configuration config) {
      HibernateConfigHelper.addMappedClasses(config);
  }

  @HibernateSession
  public void injectHibernateSession(Session session) {
      HibernateSessionManager.injectSession(session);
  }
}
+-----+

  The method annotated with @HibernateConfiguration allows performing some extra, programmatic Hibernate configuration, like e.g. registering mapped
  classes with Hibernate. This method can be abandoned if all configuration is performed in the Hibernate config files.

  The method annotated with @HibernateSession will be invoked before each test, with a Hibernate Session object as parameter. This method should make
  sure that the tested data access code uses the Hibernate Session that is supplied by Unitils. The HibernateSessionManager that is invoked in this method
  is also project specific code. The one in the example looks like the following:

+-----+
public class HibernateSessionManager {

  private static Session externallyProvidedSession;

  private static SessionFactory sessionFactory;

  public static Session getSession() {
      if (externallyProvidedSession != null) {
          return externallyProvidedSession;
      } else {
          return doGetSession();
      }
  }

  private static Session doGetSession() {
      if (sessionFactory == null) {
          initSessionFactory();
      }
      return sessionFactory.openSession();
  }

  private static void initSessionFactory() {
      Configuration configuration = new AnnotationConfiguration();
      configuration.addFile("hibernate.cfg.xml");
      configuration.addFile("hibernate-mappedClasses.cfg.xml");
      configuration.configure();
      sessionFactory = configuration.buildSessionFactory();
  }

  public static void injectSession(Session session) {
      externallyProvidedSession = session;
  }
}
+-----+

  Unitils is shipped with a ready-to-use unit test that verifies if the mapping of all your mapped classes is consistent with the database. This
  test is not automatically executed; you should write a unit test that looks like the following:

+-----+
public class HibernateMappingTest extends BaseHibernateTest {

    public void testMappingToDatabase() {
        HibernateAssert.assertMappingToDatabase();
    }
}
+-----+
  
