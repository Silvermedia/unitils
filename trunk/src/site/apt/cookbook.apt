 -----
 Cookbook
 -----
 -----

Cookbook
~~~~~~~~

    This page will guide you step-by-step through the process of getting Unitils properly configured in your own software project. This 
    cookbook contains only typical configuration. A complete documented reference of all configuration options can be found in the 
    {{{unitils-default.properties} unitils-default.properties}}. For more general information about Unitils and also information on the way Unitils 
    uses configuration files, we refer to the {{{documentation.html} documentation}} page.
   
   
* {Dependencies}
~~~~~~~~~~~~~~~~
    To be able to use these features, it is sufficient to add the unitils jar to your project's classpath.
  
  
  
* Enable support for database tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    To enable database testing as foreseen in Unitils, you should start by setting up a unit test database for every developer in your 
    team. In our typical configuration shown below, we assume that for every developer, a separate test database schema was created on the 
    same database instance.
  
    Create a file named unitils.properties and make it available in the root of your classpath. It should contain following properties:
  
+------+
# Name or path of the user specific properties file. This file should contain the necessary parameters to connect to the
# developer's own unit test schema. It is recommended to override the name of this file in the project specific properties
# file, to include the name of the project. The system will try to find this file in the classpath, the user home folder
# (recommended) or the local filesystem.
unitils.configuration.localFileName=unitils-<myproject>-local.properties

# Properties for the PropertiesDataSourceFactory
dataSource.driverClassName=<my driver classname>
dataSource.url=<my database connection url>

# This property specifies the underlying DBMS implementation. Supported values are 'oracle', 'db2', 'mysql' and 'hsqldb'.
# The value of this property defines which vendor specific implementations of ConstraintsDisabler, SequenceUpdater and
# DbClearer are chosen.
database.dialect=<my databasa dialect>
+------+

    Next, create a file unitils-<myproject>-local.properties and put this file in your local user home directory. The file should contain 
    following properties:

+------+
dataSource.userName=<developers database login username>
dataSource.password=<developers database login password>
database.schemaName=<developers database schema name>
+------+


* Enable automatic developers' database maintenance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    To enable automatic maintenance of the developers' test databases, start with adding a database scripts folder to your source control system, 
    in which you will add all your database schema update scripts.
  
    Next, add following properties to unitils.properties:
  
+------+
# If set to true, the DBMaintainer will be used to update the unit test database schema. This is done once for each
# test run, before the execution of the first class annotated with @DatabaseTest, if any.
updateDataBaseSchema.enabled=true

# Directory in which the database update scripts are located.
dbMaintainer.fileScriptSource.scripts.location=<Path to your database update script files>

# DbUnit database DTD file path
dtdGenerator.dtd.filename=<Path to your database DTD>

# Comma separated list of table names. The tables in question will not be cleaned by the DBCleaner. Tables like these
# typically contain rather static, read only or type data. The database version table, indicated by the property
# dbMaintainer.dbVersionSource.tableName, is preserved automatically, and doesn't have to be included in this list.
# The tables in the list specified by dbMaintainer.cleardb.itemsToPreserve are also left untouched.
# Note that the DBClearer doesn't take this list into account. So when fromScratch is enabled
# (dbMaintainer.fromScratch.enabled=true), these tables will be removed anyway. If you want some tables/views/sequences/...
# to be preserved when creating the database from scratch, add them to dbMaintainer.cleardb.itemsToPreserve
dbMaintainer.cleandb.tablesToPreserve=<Optional list of tables from which the data should be preserved>

# Comma separated list of database items. These can be tables / views / sequences or trigger names. These items will not
# be cleared by the DBClearer when updating the database from scratch (dbMaintainer.fromScratch.enabled=true). The tables
# in this list will also not be cleaned by the DBCleaner.
dbMaintainer.cleardb.itemsToPreserve=<Optional list of database items that shouldn't be dropped>
+------+


* Enable Hibernate support
~~~~~~~~~~~~~~~~~~~~~~~~~~
    Unitils provides out-of-the box configuration support for Hibernate. First make sure the database support is configured correctly as described above.
    You should also make sure the property <HibernateModule.configuration.implClassName> is set to the subclass of org.hibernate.cfg.Configuration that 
    you make use of. If you don't make use of annotations in Hibernate, you should change the value of this property to be the following:

+-----+
HibernateModule.configuration.implClassName=org.hibernate.cfg.Configuration
+-----+

    Typically, you will write a superclass that is used as base class for all Hibernate tests. This superclass looks like the following:

+-----+
@HibernateSessionFactory("hibernate.cfg.xml")
public abstract class BaseHibernateTest extends UnitilsJUnit3 {

    @HibernateSessionFactory
    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
        // ... (code that makes sure project code makes use of this SessionFactory)
    }

}
+-----+

    The code in this example will make sure a Hibernate <Configuration> or <AnnotationConfiguration> object is instantiated, and configured using the
    config file <hibernate.cfg.xml>. Next, a <SessionFactory> is created and the method annotated with <@HibernateSessionFactory> is be invoked before 
    each test, with the Hibernate <SessionFactory> as parameter. This method should make sure that the DAO code that is being tested uses this session. 

    Unitils is shipped with a ready-to-use unit test that verifies if the mapping of all your mapped classes is consistent with the database. This 
    test is not automatically executed; you should write a unit test that looks like the following:

+-----+
public class HibernateMappingTest extends BaseHibernateTest {

    public void testMappingToDatabase() {
        HibernateAssert.assertMappingToDatabase();
    }
}
+-----+
  
    