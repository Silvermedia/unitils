 -----
 Cookbook
 -----
 -----

Cookbook
~~~~~~~~
    This page helps you to configure Unitils and to get started quickly, using a few simple examples. This cookbook contains only typical 
    configuration. A complete documented reference of all configuration options can be found in {{{unitils-default.properties} unitils-default.properties}}. 
    For more elaborate information about Unitils and its configuration, we refer to the {{{documentation.html} tutorial}}.
   
    The third party libraries required by Unitils can be found on the {{{dependencies.html}dependencies}} page.
    
    
    
* Reflection assert
~~~~~~~~~~~~~~~~~~~
    Following examples show some possible uses of the reflection assert utility. All assertions are successful:
    
+-----+
// Exact field-by-field comparison
ReflectionAssert.assertRefEquals(new Person("John", "Doe", new Address("New street", 5, "Brussels")), 
                                 new Person("John", "Doe", new Address("New street", 5, "Brussels"));
  
// Ignore Null / 0 values in the expected object
ReflectionAssert.assertRefEquals(new Person("John", null, new Address("New street", 0, null)), 
                                 new Person("John", "Doe", new Address("New street", 5, "Brussels"), 
                                 ReflectionComparatorMode.IGNORE_DEFAULTS); 
  
// Ignore collection order
ReflectionAssert.assertRefEquals(Arrays.asList(new Person("John"), new Person("Jane")), 
                                 new Person[] {new Person("Jane", "Doe"), new Person("John", "Doe")}, 
                                 ReflectionComparatorMode.LENIENT_ORDER);
  
// Ignore null/0 values + collection order
ReflectionAssert.assertLenEquals(Arrays.asList(new Person("John"), null), 
                                 new Person[] {new Person("Jane", "Doe"), new Person("John", "Doe")});

// Check only the firstName property 
ReflectionAssert.assertPropertyLenEquals("firstName", Arrays.asList("John", "Jane"), 
                                         new Person[] {new Person("Jane", "Doe"), new Person("John", "Doe")});
      
+-----+




* Mock creation and mock injection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
    This example demonstrates the EasyMock and Injection modules. The test must extend one of Unitils base classes: UnitilsJUnit3, UnitilsJUnit4 or UnitilsTestNG.
    No extra configuration is needed.
    
+-----+
public class UserServiceTest extends UnitilsJUnit4 {
    
    @Mock 
    @InjectInto(property="userDao")
    protected UserDAO mockUserDao;
  
    @TestedObject
    protected UserService userService;

    @Test
    public void testRaiseSalary() {        
        expect(userDao.findAllUsers()).andReturn(asList(new User()));
        expect(userDao.updateSalary(null, 100));     
        EasyMockUnitils.replay();
    
        userService.raiseSalaryOfAllUsers(100);
    }    
}
+-----+

** Description    
~~~~~~~~~~~~~~

    * a lenient EasyMock mock object of type <UserDAO> is created and assigned to the <mockUserDao> field
    
    * the <userService> was not set in the setup, so an instance of <UserService> is created using the default constructor and assigned to the field
    
    * the mock is injected into the <userDao> property of the <userService> 
    
    * during the test, we first record the expected behavior. Arguments are matched using lenient reflection equals: ignoring null/0 defaults and the order of collections
    
    * <EasyMockUnitils.replay()> is called to call replay on all mocks that were created in the test
    
    * the method under test is invoked
    
    * when the test finishes, Unitils automatically calls <verify()> on all created mock objects
    
    []
    
    
* Database testing
~~~~~~~~~~~~~~~~~~
    To enable database testing the Unitils way, you should start by setting up a unit test database for every developer in your 
    team. In our typical configuration shown below, we assume that for every developer, a separate test database schema was created on the 
    same database instance.    
  
    Create a file named unitils.properties and make it available in the root of your classpath. It should contain following properties:
  
+------+
# Name or path of the user specific properties file. This file should contain the necessary parameters to connect to the
# developer's own unit test schema. It is recommended to override the name of this file in the project specific properties
# file, to include the name of the project. The system will try to find this file in the classpath, the user home folder
# (recommended) or the local filesystem.
unitils.configuration.localFileName=unitils-<myproject>-local.properties

# Properties for the PropertiesDataSourceFactory
dataSource.driverClassName=<my driver classname>
database.url=<my database connection url>

# This property specifies the underlying DBMS implementation. Supported values are 'oracle', 'db2', 'mysql' and 'hsqldb'.
# The value of this property defines which vendor specific implementations of ConstraintsDisabler, SequenceUpdater and
# DbClearer are chosen.
database.dialect=<my databasa dialect>
+------+

    Next, create a file unitils-<myproject>-local.properties and put this file in your local user home directory. The file should contain 
    following properties:

+------+
database.userName=<developers database login username>
database.password=<developers database login password>
database.schemaName=<developers database schema name>
+------+




* Enable automatic developers' database maintenance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    To enable automatic maintenance of the developers' test databases, start with adding a database scripts folder to your source control system, 
    in which you will add all your database schema update scripts.
  
    Next, add following properties to unitils.properties:
  
+------+
# If set to true, the DBMaintainer will be used to update the unit test database schema. This is done once for each
# test run, before the execution of the first class annotated with @DatabaseTest, if any.
updateDataBaseSchema.enabled=true

# Directory in which the database update scripts are located.
dbMaintainer.fileScriptSource.scripts.location=<Path to your database update script files>

# DbUnit database DTD file path
dtdGenerator.dtd.filename=<Path to your database DTD>

# Comma separated list of table names. The tables in question will not be cleaned by the DBCleaner. Tables like these
# Comma separated list of table names. The tables in question will not be cleaned by the DBCleaner. Tables like these
# typically contain rather static, read only or type data. The database version table, indicated by the property
# dbMaintainer.dbVersionSource.tableName, is preserved automatically, and doesn't have to be included in this list.
# The tables in the list specified by dbMaintainer.cleardb.itemsToPreserve are also left untouched.  
# Note that the DBClearer doesn't take this list into account. So when fromScratch is enabled
# (dbMaintainer.fromScratch.enabled=true), these tables will be removed anyway. If you want some tables/views/sequences/...
# to be preserved when creating the database from scratch, add them to dbMaintainer.cleardb.itemsToPreserve
dbMaintainer.cleanDb.tablesToPreserve=<Optional list of tables from which the data should be preserved>

# Comma separated list of database items. These can be tables / views / sequences or trigger names. These items will not
# be cleared by the DBClearer when updating the database from scratch (dbMaintainer.fromScratch.enabled=true). The tables
# in this list will also not be cleaned by the DBCleaner.
dbMaintainer.clearDb.itemsToPreserve=<Optional list of database items that shouldn't be dropped>
+------+

    After this, place one or more scripts in the folder configured by dbMaintainer.fileScriptSource.scripts.location that 
    create you database tables. E.g.:
    
+-----+
dbscripts / 001_user_table.sql
            002_company_table.sql

+-----+

    Following is an example of a database test:
    
+-----+
public class UserDaoTest extends UnitilsJUnit4 {

    // DataSource that provides access to unit test database is injected
    @TestDataSource
    public void setDataSource(DataSource dataSource) {
        // ... (code that makes sure projects makes use of this DataSource)
    }

    // DbUnit dataset file with name UserDaoTest.xml or UserDaoTest.testFindUserByLastName.xml is loaded
    @DataSet
    @Test
    public void testFindUserByLastName() {
        List<User> users = userDao.findByLastName("Doe");
        assertLenEquals("firstName", Arrays.asList("John", "Jane"), users);
    }
}
+-----+

    Test data file UserDaoTest.xml:

+-----+
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE dataset SYSTEM "<path to database dtd>">
<dataset>
    <user firstname="John" lastname="Doe"/>
    <user firstname="Jane" lastname="Doe"/>
    <user firstname="Jack" lastname="Smith"/>
</dataset>
+-----+




* Enable Hibernate support
~~~~~~~~~~~~~~~~~~~~~~~~~~
    To make use of Unitils' Hibernate support, first make sure the database support is configured correctly as described above and that you have hibernate
    in your classpath. Also make sure the property <HibernateModule.configuration.implClassName> is set to the subclass of org.hibernate.cfg.Configuration that 
    you make use of. If you don't make use of Hibernate with annotations, change the value of this property to be the following:

+-----+
HibernateModule.configuration.implClassName=org.hibernate.cfg.Configuration
+-----+

    Now you're ready to start writing tests with Hibernate, e.g.:

+-----+
// A Hibernate <Configuration> or <AnnotationConfiguration> object is instantiated, and configured using the
// config file <hibernate.cfg.xml>
@HibernateSessionFactory("hibernate.cfg.xml")
public class BaseHibernateTest extends UnitilsJUnit3 {

    // A <SessionFactory> is created and this method is called before each test with the 
    // SessionFactory as parameter
    @HibernateSessionFactory
    public void setSessionFactory(SessionFactory sessionFactory) {
        // ... (code that makes sure project code makes use of this SessionFactory)
    }
  
    @Test
    public void testFindUserByLastName() {
        List<User> users = hibernateUserDao.findByLastName("Doe");
        ReflectionAssert.assertLenEquals("firstName", Arrays.asList("John", "Jane"), users);
    }

}
+-----+

    Unitils is shipped with a ready-to-use unit test that verifies if the mapping of all your mapped classes is consistent with the database. This 
    test is not automatically executed; you should write a unit test that looks like the following:

+-----+
public class HibernateMappingTest extends BaseHibernateTest {

    public void testMappingToDatabase() {
        // Verify the mapping of all hiberate mapped objects with the database
        HibernateUnitils.assertMappingToDatabase();
    }
}
+-----+
  
  
  
  
* Spring integration
~~~~~~~~~~~~~~~~~~~~
    Aside from ApplicationContext management and injection of Spring beans in your test, Unitils' Spring integration allows testing using a
    Hibernate SessionFactory that is configured in Spring:
    
+-----+
// Create a Spring ApplicationContext object and intialized with the file services-config.xml
@ApplicationContext("services-config.xml")
public class UserDaoTest extends UnitilsJUnit4 {

    // The userDao bean, which is wired with an SessionFactory that is connected to the UnitilsDataSource, 
    // is injected into the userDao field
    @SpringBean("userDao")
    protected UserDao userDao;
  
    public void testFindUserByLastName() {
        List<User> users = hibernateUserDao.findByLastName("Doe");
        assertLenEquals("firstName", Arrays.asList("John", "Jane"), users);
    }
  
    public void testMappingToDatabase() {
        // Verify the mapping of all hiberate mapped objects with the database
        HibernateAssert.assertMappingWithDatabaseConsistent();
    }
}
+-----+

    services-config.xml:

+-----+
<?xml version="1.0" encoding="UTF-8"?>
<beans>

    <bean id="userDao" class="org.unitils.cookbook.UserDao">
        <property name="sessionFactory" ref="sessionFactoryBean"/>
    </bean>

    <bean id="sessionFactoryBean" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="annotatedClasses">
            <list>
                <value>org.unitils.sample.cookbook.User</value>
            </list>
        </property>
        <property name="hibernateProperties">
            <value>
            ...
            </value>
        </property>
    </bean>

    <bean id="dataSource" class="org.unitils.database.UnitilsDataSource" />
  
</beans>
+-----+
