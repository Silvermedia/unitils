<document>
    <properties>    
        <title>Testing Spring - Hibernate applications with Unitils</title>
    </properties>  
    <body>    
        <section name="Testing Spring - Hibernate applications with Unitils">        

<p>This article demonstrates a brand new open source library for unit testing, called Unitils. Unitils helps you in writing simple and maintainable 
unit tests with <a href="http://www.junit.org/">JUnit</a> or <a href="http://testng.org/">TestNG</a>. It glues together some widely used test libraries 
like <a href="http://www.dbunit.org/">DbUnit</a> and <a href="http://www.easymock.org">EasyMock</a> and offers integration with 
<a href="http://www.springframework.org">Spring</a> and <a href="http://www.hibernate.org/">Hibernate</a>. Unitils encourages applying good practices and 
unit testing guidelines. The ideas behind the code are based on the authors' concrete experience on enterprise projects.</p>

<p><b>Unitils offers following features</b></p>
<ul>
    <li><p>Equality assertion through reflection, with options like ignoring Java default/null values and ignoring order of collections</p></li>
    <li><p>Support for database testing involving test data management with DbUnit, automatic maintenance of unit test databases and automatic constraints disabling</p></li>
    <li><p>Hibernate integration features such as session management and testing the mapping with the database</p></li>
    <li><p>Integration with Spring, involving ApplicationContext management and injection of spring managed beans</p></li>
    <li><p>Integration with EasyMock and injection of mocks into other objects</p></li>
</ul>

<p>In what follows, we demonstrate some of Unitils' most powerful features with a simple example: a test for a DAO method that uses Hibernate to 
connect to a relational database.</p>

<br />
<h3>The example</h3>

<p>Suppose we have a Phonebook interface for which we've written an implementation using Hibernate and Spring's HibernateDaoSupport. The Phonebook 
interface has a method <i>searchByLastName</i> and is implementated as follows:</p>

<div class="source"><pre>
public class HibernatePhonebook extends HibernateDaoSupport implements Phonebook {

    public List&lt;Person&gt; searchByLastName(String lastName) {
        return (List&lt;Person&gt;) getHibernateTemplate().executeFind(new HibernateCallback() {
                public Object doInHibernate(Session session) throws HibernateException, SQLException {
                    Criteria personCriteria = session.createCriteria(Person.class);
                    personCriteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);
                    personCriteria.add(Restrictions.like("lastName", criteria.getLastName(), MatchMode.ANYWHERE));
                    return personCriteria.list();
                }
        });
    }
}
</pre></div>

<p>We've written following test for this method:</p>

<div class="source"><pre>
@ApplicationContext({"classpath:services-config.xml", "classpath:test-ds-config.xml"})
public class UnitilsHibernatePhonebookTest extends UnitilsJUnit3 {
    
    @SpringBeanByType
    private Phonebook phonebook;

    @DataSet
    public void testSearchByLastName() {
        List&lt;Person&gt; result = phonebook.searchByLastName("Doe"));        
        ReflectionAssert.assertPropertyLenEquals("firstName", Arrays.asList("John", "Jane"), result);    
    }
}
</pre></div>

<p>This example test seems to be a plain old JUnit test. But when it's executed, a lot of magic happens behind the scenes. This 'magic' is in fact the 
Unitils framework that hooks in to the execution of the test and inspects the test for annotations that ask for extra behavior to be performed.
Let's take a look at the lines of code and annotations of interest and explain their effect.</p>




<div style="padding-top: 15px"><b><i>Unitils-enabling the test</i></b></div>

<p>First of all, the class definition states:</p>

<div class="source"><pre>
public class UnitilsHibernatePhonebookTest extends UnitilsJUnit3 {
</pre></div>

<p>Extending from UnitilsJUnit3 is the simplest way to make a test Unitils-enabled. It not only makes this class a JUnit3 test (in fact, 
<i>UnitilsJunit3</i> is a subclass of <i>junit.framework.TestCase</i>), but it also contains logic that enables Unitils to hook up into the execution of a 
unit test. For JUnit4 and TestNG, Unitils offers similar base classes called <i>UnitilsJUnit4</i> and <i>UnitilsTestNG</i>, respectively.</p>





<div style="padding-top: 15px"><b><i>Creating an application context and retrieving a Spring bean</i></b></div>

<p>The <i>UnitilsHibernatePhonebookTest</i> class is annotated like this:</p>

<div class="source"><pre>
@ApplicationContext({"classpath:services-config.xml", "classpath:test-ds-config.xml"})
</pre></div>

<p>The <i>@ApplicationContext</i> annotation instructs Unitils to create a Spring <i>ApplicationContext</i>, in which the <i>services-config.xml</i> and 
<i>test-ds-config.xml</i> files are loaded. This enables us to make Spring wired beans available for testing in a simple way:</p>

<div class="source"><pre>
@SpringBeanByType
private Phonebook phonebook;
</pre></div>

<p>By annotating the phonebook field with <i>@SpringBeanByType</i>, we tell the system to find a bean of type PhoneBook in the application context and inject it 
into the annotated field. Setter injection is also supported: simply move the annotation to a setter with the matching type. If you prefer injection by name, you 
can use either <i>@SpringBean</i> or <i>@SpringBeanByName</i>. When using <i>@SpringBean</i>, you have to specify the bean's name explicitly; in case of 
<i>@SpringBeanByName</i>, the name of the target setter or field is used.</p>

<p>A similar functionality can by achieved by extending Spring's own <i>AbstractDependencyInjectionSpringContextTests</i>. But the strength of Unitils is that 
it goes further, integrating with other testing tools such as DbUnit and enabling you to do the same with other test frameworks.</p>





<div style="padding-top: 15px"><b><i>Configuring the application context</i></b></div>

<p>Let's take a look at <i>services-config.xml</i> and <i>test-ds-config.xml</i>:</p>

<div class="source"><pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans&gt;

    &lt;bean id="phonebook" class="org.unitils.sample.phonebook.impl.HibernatePhoneBook"&gt;
        &lt;property name="sessionFactory" ref="sessionFactoryBean"/&gt;
    &lt;/bean&gt;

    &lt;bean id="sessionFactoryBean" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
        &lt;property name="annotatedClasses"&gt;
            &lt;list&gt;
                &lt;value&gt;org.unitils.sample.phonebook.domain.Person&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;value&gt;
                hibernate.dialect=org.hibernate.dialect.HSQLDialect
                hibernate.show_sql=true
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    
&lt;/beans&gt;
</pre></div>

<div class="source"><pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans&gt;
    &lt;bean id="dataSource" class="org.unitils.database.UnitilsDataSource" /&gt;
&lt;/beans&gt;
</pre></div>

<p>The first one, <i>services-config.xml</i>, is a general spring configuration file for our application, the bean definitions in this file don't need to be 
modified for testing purposes. The second file, <i>test-ds-config.xml</i>, defines the test datasource for the phonebook service. This file exists for testing 
purposes only, another spring configuration file exists that defines the <i>DataSource</i> for normal application use.</p>

<p>The data source is an instance of <i>UnitilsDataSource</i>. It is a connection pooled data source, providing access to the unit-test database. 
The configuration of this data source is specified in a Unitils configuration file. We won't explain how to configure Unitils in this article, for this 
we refer to our <a href="cookbook.html">cookbook</a> and <a href="tutorial.html">tutorial</a> pages.</p>





<div style="padding-top: 15px"><b><i>Loading a test data set</i></b></div>

<p>Now let's return to the test. To make sure test data is loaded, we can use the <i>@DataSet</i> annotation either on class level (load test data for every 
method) or on method level (load test data for this method only). In our example, the method is annotated:</p>

<div class="source"><pre>
@DataSet
public void testSearch() {
</pre></div>

<p>This will make sure that before running the test, our test database is populated with data from a dataset file. The system searches for a DbUnit 
file either named <i>UnitilsHibernatePhonebookTest.testSearch.xml</i> or <i>UnitilsHibernatePhonebookTest.xml</i>. The former can be used if you want to create a 
dataset for one method specifically, the latter is the default one for all the tests in this test class. The dataset is formatted as a DbUnit 
<i>FlatXmlDataSet</i> as follows:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;dataset&gt;
    &lt;PERSON FIRSTNAME="John" LASTNAME="Doe" /&gt;
    &lt;PERSON FIRSTNAME="Jane" LASTNAME="Doe" /&gt;
    &lt;PERSON FIRSTNAME="Jim"  LASTNAME="Smith" /&gt;
&lt;/dataset&gt;
</pre></div>




<div style="padding-top: 15px"><b><i>Checking the result</i></b></div>

<p>After this, the unit test is executed. To express assert statements, we use Unitils' reflection assert utility. This utility uses java reflection to 
compare all fields of the expected and actual object and all objects that are referenced by the expected or actual ones. You can also check whether a 
certain property of every object in a collection matches a collection of expected values. E.g. you can specify the following:</p>

<div class="source"><pre>
ReflectionAssert.assertRefEquals(new Person("John", "Doe"), result.get(0));
ReflectionAssert.assertPropertyRefEquals("firstName", Arrays.asList("John", "Jane"), result);    
</pre></div>

<p>The first assertion checks whether all field values of the Person object, in this case the first and last name, match those of the expected object. 
The second one checks whether the first names of the objects in the result list are "John" and "Jane".</p>

<p>A number of leniency levels is offered too. You can for example ignore fields that have a null/0 Java default value in the expected object or ignore 
the order of elements in a collection. These leniency levels are offered by default by the <i>assert<b>Len</b>Equals</i> 
(instead of <i>assert<b>Ref</b>Equals</i>) methods. For example:</p>

<div class="source"><pre>
ReflectionAssert.assertLenEquals(new Person("John", null), result.get(0));
ReflectionAssert.assertPropertyLenEquals("firstName", Arrays.asList("John", "Jane"), result);    
</pre></div>

<p>The first statement verifies that the <i>firstName</i> field in the result object equals to "John", it ignores the other fields. The second one 
checks whether the values of the <i>firstName</i> fields in the result person list are "John" and "Jane", ignoring the actual order of these values.</p>




<br />
<h3>Hibernate mapping test</h3>

<p>Unitils contains a very simple but powerful mapping test. This test checks whether the mapping of all Hibernate mapped objects is consistent with the 
database. To activate it, just add following test to your test suite:</p>

<div class="source"><pre>
@ApplicationContext({"classpath:services-config.xml", "classpath:test-ds-config.xml"})
public class HibernateMappingTest extends UnitilsJUnit3 {

    public void testMappingToDatabase() {
        HibernateUnitils.assertMappingWithDatabaseConsistent();
    }
}
</pre></div>

<p>Suppose that the column PERSON.FIRSTNAME is missing in the test database. This will make the test fail with a message indicating that this column 
should be added:</p>

<div class="source"><pre>
AssertionFailedError: Found mismatches between Java objects and database tables. 
Applying following DDL statements to the database should resolve the problem: 
alter table PERSON add column firstName varchar(255);
</pre></div>

<p>You may have noticed that the <i>@ApplicationContext</i> annotation reappears in the test. To avoid this duplication, you can create a common superclass for 
all database tests that contain the configuration.</p>




<br />
<h3>Unit test database maintenance</h3>

<p>To keep database tests maintainable, test data files have to be as small as possible. (Referential) constraints however don't help you to achieve this. 
We advise to disable all foreign key and not null constraints. Doing so makes it possible to specify only the data that matters for your test. To make 
sure tests can be run without being affected by others, we also advise to let every developer have its own test database or test database schema.</p>

<p>To help you with this, Unitils provides a powerful database maintainer offering features such as automatic maintainance of your unit test schemas, 
disabling of the foreign key and not-null constraints and generating a DTD for DbUnit dataset files. Explaining the full workings of the database 
maintainer would lead us too far for this article. We'll just give a simple example to give you an impression of how this works. Consult
the <a href="tutorial.html">tutorial</a> for a more in depth example.</p>

<p>The database maintainer monitors a directory on the filesystem that contains DDL scripts for creating the structure of the database. The name of these scripts 
should comply with following naming convention: &lt;version&gt;_&lt;some name&gt;.sql. For example:</p>

<div class="source"><pre>
dbscripts/ 001_create_person_table.sql
           002_create_car_table.sql
</pre></div>

<p>Each unit test database or schema contains a table in which it stores its current version number. In this case, the version number of the database will be 2.</p>

<p>Suppose we add a file named <i>003_add_phonenumber.sql</i> to this directory. The next time a database test is executed, the database maintainer will notice that the
structure of the unit test database is no longer up to date and executes the new script on the database. It then increases the version of the database. Changes to 
existing files, e.g. <i>001_create_person_table.sql</i> will also be detected by the database maintainer. In that case, it will drop all tables in the test database 
and recreate it from scratch, starting again from the first script.</p>




<br />
<h3>Conclusion</h3>

<p>In this article we've tried to demonstrate how Unitils can improve your tests, using a few simple examples. If you're curious to learn more about Unitils, check out the 
<a href="tutorial.html">tutorial</a>, <a href="cookbook.html">cookbook</a> and our <a href="guidelines.html">unit testing guidelines</a>.</p>

<p>We value your opinion. Let us know what you think. If you have any comments, tips or questions please post them on the user forum or contact us directly by sending 
a mail to <i>filip_neven at users.sourceforge.net</i> or <i>tim_ducheyne at users.sourceforge.net</i>.</p>


<br />
<h3>About the authors</h3>
<p><b>Filip Neven</b> and <b>Tim Ducheyne</b> are senior software enigneers at <a href="http://www.j-technologies.be/">Ordina Belgium</a>. They each have more 
than 6 years experience in designing and developing Java enterprise applications. They were the leaders of an expert group on unit testing within Ordina. 
Later, they founded the Unitils open source project in which they worked out a number of their ideas. Today they are still actively working on 
Unitils as the project's lead developers. Recently, Filip gave a Quicky presentation on Unitils at the Javapolis conference.</p>



<br />
<br />

    </section>
  </body>
</document>