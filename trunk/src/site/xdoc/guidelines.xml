<document>
  <properties>    
    <title>Guidelines</title>
  </properties>  
  <body>
    <!-- The body of the document contains a number of sections -->
    <section name="Guidelines">        
    
<p>Unitils started as a discussion group on unit testing. The result of these discussions is the list of guidelines found on this page.</p>

<p><a href="#1">1. Introduction</a></p>
<p><a href="#2">2. General Guidelines</a></p>
<ul>
    <li><p><a href="#2.1">2.1 Structure of a unit test</a></p></li>
    <li><p><a href="#2.2">2.2 Naming Conventions</a></p></li>    
    <li><p><a href="#2.3">2.3 Put unit tests in same package but separate source folder</a></p></li>
    <li><p><a href="#2.4">2.4 Create test data during setup</a></p></li>
    <li><p><a href="#2.5">2.5 Keep your test fixture simple</a></p></li>
    <li><p><a href="#2.6">2.6 Test boundary conditions</a></p></li>
    <li><p><a href="#2.7">2.7 Test public interface, not internals</a></p></li>
    <li><p><a href="#2.8">2.8 Keep test methods small</a></p></li>
    <li><p><a href="#2.9">2.9 Create independent unit tests</a></p></li>
    <li><p><a href="#2.10">2.10 Write tests while writing code</a></p></li>
    <li><p><a href="#2.11">2.11 Use reflection for equality checking</a></p></li>
    <li><p><a href="#2.12">2.12 Everyone tests or no one tests</a></p></li>
    <li><p><a href="#2.13">2.13 Fix broken tests immediately</a></p></li>
    <li><p><a href="#2.14">2.14 Use continuous integration</a></p></li>
    <li><p><a href="#2.15">2.15 Use build tool or IDE to run suites of tests</a></p></li>
    <li><p><a href="#2.16">2.16 Write test when fixing a bug</a></p></li>
    <li><p><a href="#2.17">2.17 Test new project code, not library code</a></p></li>
    <li><p><a href="#2.18">2.18 Test declared exceptions</a></p></li>
</ul>
<p><a href="#3">3. Database testing guidelines</a></p>
<ul>
    <li><p><a href="#3.1">3.1 Test with unit test databases</a></p></li>
    <li><p><a href="#3.2">3.2 Automate the maintenance of the test databases</a></p></li>
    <li><p><a href="#3.3">3.3 Disable foreign key and not null constraints</a></p></li>
    <li><p><a href="#3.4">3.4 Testing simple CRUD methods</a></p></li>
    <li><p><a href="#3.5">3.5 Testing queries</a></p></li>
    <li><p><a href="#3.6">3.6 Testing bulk data manipulation methods</a></p></li>
    <li><p><a href="#3.7">3.7 Keep your test data files simple</a></p></li>
    <li><p><a href="#3.8">3.8 Make data sets test class specific</a></p></li>
    <li><p><a href="#3.9">3.9 Use a DTD in your test data files</a></p></li>
    <li><p><a href="#3.10">3.10 Do not test auto-generated fields</a></p></li> 
    <li><p><a href="#3.11">3.11 Modify database sequences</a></p></li>
    <li><p><a href="#3.12">3.12 Don’t use transactions</a></p></li>
</ul>
<p><a href="#4">4. O/R mapping testing guidelines</a></p>
<ul>
    <li><p><a href="#4.1">4.1 Test mapping with database</a></p></li>
    <li><p><a href="#4.2">4.2 Test non-trivial queries</a></p></li>
    <li><p><a href="#4.3">4.3 Test bulk data manipulation methods</a></p></li>
</ul>


<p>The guidelines are work in progress and are intended to be open source. We have a <a href="http://sourceforge.net/forum/forum.php?forum_id=642599">
guidelines forum</a> on which guidelines can be discussed and new ones can be proposed. We hope to hear from you. Feel free to post your comments.</p>


<br />    
<h2><a name="1">1. Introduction</a></h2>

<p>A unit test is a piece of code written by a developer that tests another piece of code. Usually a unit test 
executes some particular method in a particular context, and it checks if the outcome matches the expected one. 
Unit tests are independent of each other, so that the sequence in which they are executed is of no importance. 
They can be executed without user intervention, which makes them very useful as automatic regression tests.</p>



<h4>Why write unit tests?</h4>

<p>Unit tests ensure that a piece of code really works at the time of writing, and that it keeps on working after 
subsequent changes to the code. Unit testing will reduce the time you spend on debugging, and it will improve your 
designs. It will make sure you have confidence in the code. It is a great help when refactoring, since it gives 
you direct feedback in case you break something. Unit tests also act as documentation, since they show how a method 
should be used and what boundary conditions it can handle.</p>

<p>The number one argument against unit testing is that it takes too much time. This not true, it will save you time 
instead, because of its immediate and constant feedback, and since it greatly reduces the debugging efforts you have 
to spend afterwards. It will make sure you fix bugs early that you would have found late when following a no-unit 
testing approach. This doesn’t mean we ignore the fact unit testing takes time. It does take longer to write both 
code and unit tests, but the complete, correctly functioning product will be delivered earlier, and it will be much 
more maintainable afterwards.</p>

<p>The unit testing strategy is part of your project methodology and should be discussed in advance, in 
cooperation  with the customer. The customer must be aware of and agree with the fact that you choose the unit 
testing approach. He has to be aware of the fact that daily coding will take some more time, but that the eventual 
stable product will be delivered sooner.</p>

<p>Each of the unit-tests test only a small part of the code. There should also be other kinds of tests on 
the project that test the code as whole. Examples are integration tests, user acceptance tests and performance tests.</p>




<h4>Pragmatic unit testing</h4>

<p>There are many possible levels of doing unit-testing. Some people want to reach 100% code coverage: every 
line of code is used in at least one test. Of course this requires you to write lots and lots of tests, probably spending 
more time writing and maintaining tests than writing code.</p>

<p>The other extreme is writing no tests at all. We think the ideal lies somewhere in the middle. Adding a few unit tests 
for some piece of code already catches most of the bugs in that code while staying maintainable and keeping focus on the 
project code.</p>

<p>A possible set of unit tests per piece of code can include:</p>
<ul>
    <li><p>a test for the main flow (the happy path)</p></li>
    <li><p>tests for the main alternative flows</p></li>
    <li><p>tests for boundary conditions (such as null arguments)</p></li>
</ul>

<p>The main focus of the guidelines is to make unit-testing easy and maintainable. Writing a test should be quick and a 
test should not hinder you when code is being altered and refactored.</p>

<p>Deciding on a unit testing strategy means deciding which layers of the software system will be tested (GUI, business, 
database), and what tools and libraries will be used. What is best chosen highly depends on the project, but typically you 
would at least test the business and database layers.</p>



<h4>Unit testing libraries</h4>

<p>We’ve chosen to use following libraries to aid us in writing
unit tests:</p>

<ul>
    <li><p><a href="http://www.junit.org/">JUnit</a> - base test library</p></li>
    <li><p><a href="http://testng.org/">TestNG</a> - base test library</p></li>
    <li><p><a href="http://dbunit.sourceforge.net/">DbUnit</a> - tests using a database</p></li>
    <li><p><a href="http://sourceforge.net/projects/junit-addons">JUnit Addons</a> - testing utilities</p></li>
    <li><p><a href="http://www.easymock.org/">EasyMock</a> - simulating behavior</p></li>
</ul>

<p>Aside from these libraries there is also a library that we created our own, that already implements or helps 
implementing many of the functionality described by the guidelines: <b>Unitils</b></p>




<br />
<h2><a name="2">2. General Guidelines</a></h2>



<div class="section"><h3><a name="2.1"></a>2.1 Structure of a unit test</h3>


<h4>Short Description</h4>

<p>A unit test generally consists of following parts:</p>
<ul>
    <li><p>Class under test instance</p></li>
    <li><p>Test data instances (also called test fixture)</p></li>
    <li><p>Setup of test data</p></li>
    <li><p>Test methods</p></li>
    <li><p>Utility methods</p></li>
</ul>

<p><i>For each test method:</i></p>
<ul>
    <li><p>(Optional) Test specific setup</p></li>
    <li><p>Execution of the method under test</p></li>
    <li><p>Verification of the results, using assert statements</p></li>
</ul>



<h4>Description</h4>

<p>Test classes typically contain a data setup part and a test part. The setup part is performed in 
the setUp() method and contains the instantiation of the class under test instance and all objects that 
will be used as data during the test (See  <a href="#2.4">Create test data during setup</a>). 
The class under test instance is the object on which methods will be called to perform the actual tests. 
There should only be one such instance per test class and it should be created in the setUp() method.</p>

<p>Verification of results is performed by using JUnit’s assert statements. You should only add asserts if they are of value 
for the test (See <a href="#2.8">Keep test methods small</a>). If objects need to be compared, use Unitils’ ReflectionAssert 
instead of a regular assertEquals() (See <a href="#2.11">Use reflection for equality checking</a>). Assert statements can have 
messages as arguments that will be used when the assertion fails. These messages do not have much added-value and can therefore 
be left out. E.g. both assertions below deliver the same result, but it's less work to use the second version:</p>
 
<p><pre><code>  assertEquals(“Name is not equal”, “John”, result.getFirstName());
  assertEquals(“John”, result.getFirstName());</code></pre></p>

<p>All bad smells that you can have for regular code you can also have in your test code. Test classes can for 
example contain duplicate code or become too big because too many tests were added to them. You should
react to these smells as you would with normal code: refactor the code.</p>


<h4>Examples</h4>

<div class="source"><pre>
package org.unitils.util;

import junit.framework.TestCase;

/**
 * Test class for {@link UserAdmin}.
 * Contains tests with …
 */
public class UserAdminTest extends TestCase {

    /* Class under test */
    private UserAdmin userAdmin;                            <span class="code-comment">// Class under Test</span>

    /* A simple test user */                                <span class="code-comment">//</span>
    private User user;                                      <span class="code-comment">// Test Data (Fixture)</span>
                                                            <span class="code-comment">//</span>
    /* An administrator role */                             <span class="code-comment">//</span>
    private Role adminRole;                                 <span class="code-comment">//</span>


    /**
     * Initializes the test fixture.
     */
    protected void setUp() throws Exception {
        super.setUp();                                      <span class="code-comment">// Superclass Setup</span>

        userAdmin = new UserAdmin();                        <span class="code-comment">// Create Class under Test</span>

        user = new User(“John”, “Doe”);                     <span class="code-comment">//</span>
        adminRole = new Role(“Administrator”);              <span class="code-comment">// Test Data Setup</span>
    }


    /**
     * Test for method with …
     */
    public void testAddUser_oldEnough() {
        user.setAge(18);                                    <span class="code-comment">// Extra Test Setup</span>

        userAdmin.addUser(“jdoe”, user, adminRole);         <span class="code-comment">// Perform Test</span>

        User result = userAdmin.getUser(“jdoe”);            <span class="code-comment">//</span>
        assertEquals(“John”, result.getFirstName());        <span class="code-comment">// Verify Results</span>
        assertEquals(“Doe”, result.getLastName());          <span class="code-comment">//</span>
    }
}
</pre></div>

</div>







<div class="section"><h3><a name="2.2">2.2 Naming Conventions</a></h3>


<h4>Short Description</h4>

<p><i>For the test classes:</i></p>
<ul>
    <li><p>&lt;class name&gt; + <i>‘Test’</i></p></li>
    <li><p>If there are multiple test classes for one class: &lt;class name&gt; + &lt;description of tested behavior&gt; + <i>‘Test’</i></p></li>
</ul>

<p><i>For the test methods: </i></p>
<ul>
    <li><p>For the ‘happy path’:  ‘test’ + &lt;method name&gt;</p></li>
    <li><p>For all special cases: ‘test’ + &lt;method name&gt; + ‘_’ + &lt;description of special case&gt;</p></li>
</ul>


<h4>Description</h4>

<p>Proper naming of unit tests is important: it enables other developers and tools to easily locate the test classes and methods.</p>

<p>When creating a new test class, name the new class after the class that is being tested and add the suffix <i>‘Test’</i>. 
If there is more than 1 test class for a certain class (see <a href="#2.5">Keep your test fixture simple</a>) use the same 
convention, but add an extra name in front of ‘Test’. This extra name is free to choose but should give an indication 
of the kind of tests that are going to be in this class.</p>

<p>The naming of test methods is similar, but instead of using a suffix, we use a prefix <i>‘test’</i>, followed by the name of 
the method under test (capitalize the first letter as with other method names). If there is more than 1 test for a certain method 
name all special cases by adding an underscore (‘_’) and an extra name. This extra name is again free to choose but should give an 
indication of the subject of the test.</p>


<h4>Examples</h4>
<p><table>
    <tr><td></td>               <td><b><i>Class/method under test</i></b></td>      <td><b><i>Test class/method</i></b></td></tr>
    <tr><td>Typical</td>        <td>ArrayList</td>                                  <td>ArrayList<b>Test</b></td></tr>
    <tr><td>Multiple tests</td> <td>ArrayList</td>                                  <td>ArrayList<b>Test</b></td></tr>
    <tr><td></td>               <td></td>                                           <td>ArrayList<b>SortingTest</b></td></tr>
    <tr><td></td>               <td></td>                                           <td>ArrayList<b>IteratorTest</b></td></tr>
    <tr><td>Happy path</td>     <td>add(int index, Object element)</td>             <td><b>test</b>Add()</td></tr>
    <tr><td>Special cases</td>  <td>add(int index, Object element)</td>             <td><b>test</b>Add<b>_nullElement</b>()</td></tr>
    <tr><td></td>               <td></td>                                           <td><b>test</b>Add<b>_negativeIndex</b>()</td></tr>
</table></p>

</div>




<div class="section"><h3><a name="2.3">2.3 Put unit tests in same package but separate source folder</a></h3>


<h4>Short Description</h4>

<p>Put test classes in the same package as the tested code but store them in a separate source tree.</p>


<h4>Description</h4>

<p>Test classes should be easy to locate. Creating test classes in the same package as the class under test and 
using the correct <a href="#2.2">naming conventions</a> enables you to find all tests of a class very quickly. Furthermore, 
sharing the same package will enable you, if necessary, to test protected and package-protected methods.</p>

<p>Test artifacts are only of use during development. They should not be included in the end-deliverables. Putting test code in 
a different source directory gives a clean separation of test code and production code. It will make it easier to create 
deliverables such as JARs and EARs that do not include any of the test classes.</p>


<h4>Examples</h4>

<p><code><pre>
    <b>src/main/java</b>      /org/unitils/util/StringUtils.java
    <b>src/main/resources</b> /project.properties
    <b>src/test/java</b>      /org/unitils/util/StringUtilsTest.java
    <b>src/test/resources</b> /unitils.properties
</pre></code></p>
</div>




<div class="section"><h3><a name="2.4">2.4 Create test data during setup</a></h3>


<h4>Short Description</h4>

<p>Put all non-trivial test data creation in the setUp() method of your test. </p>

<p><i>Test methods </i></p>

<ul>
    <li><p>can use objects that were created during the setup of the test class</p></li>
    <li><p>may perform additional configuration (not creation) of test data during its own setup</p></li>
</ul>


<h4>Description</h4>

<p>If you need non-trivial test data in your test methods, put them in instance variables of the test class. Initialize the 
instance variables during the setup phase of the test. This set of test data instances is called the fixture of the test. Trivial 
test data such as strings and integers should not be added to the fixture and can be used directly as arguments in the test methods.</p>

<p>Putting test data in instance variables will promote reuse of test data and will keep test methods small and maintainable.</p>

<p>If needed a test method can perform modifications to the test data. This extra setup should however be used 
as an exception and be limited to changing a few values of the already created test data. JUnit and TestNG initialize the fixture 
before each of the test methods so changing the test data will not cause problems for other test methods.</p>

<p>If the set of test data becomes too large (too many instance variables) and is incoherent, split the 
tests into multiple test classes (see <a href="#2.5">Keep your test fixture simple</a>). Because not all 
test data is used by every test, splitting up tests will also avoid creation of too much unused test data.</p>

<p>Note: do not forget to call super.setUp(). Some superclasses, e.g. DatabaseTestCase, perform there own setting up in the
setUp() method.</p>


<h4>Examples</h4>

<div class="source"><pre>
public class UserAdminTest extends TestCase {

    /* Class under test */
    private UserAdmin userAdmin;  

    /* A simple test user */                                <span class="code-comment">//</span>                     
    private User user;                                      <span class="code-comment">//</span>
                                                            <span class="code-comment">// Test Data (Fixture)</span>
    /* An administrator role */                             <span class="code-comment">//</span>
    private Role adminRole;                                 <span class="code-comment">//</span>


    /**
     * Initializes the test fixture.
     */
    protected void setUp() throws Exception {
        super.setUp();

        userAdmin = new UserAdmin();
        user = new User(“John”, “Doe”);                     <span class="code-comment">// Test Data Setup</span>
        adminRole = new Role(“Administrator”);              <span class="code-comment">//</span>
    }


    /**
     * Test for method with …
     */
    public void testAddUser_oldEnough() {
        user.setAge(18);                                    <span class="code-comment">// Extra Test Setup</span>

        userAdmin.addUser(“jdoe”, user, adminRole);         <span class="code-comment">// Use Test Data</span>

        User result = userAdmin.getUser(“jdoe”);
        assertEquals(“John”, result.getFirstName());
        assertEquals(“Doe”, result.getLastName()); 
    }
}
</pre></div>

</div>




<div class="section"><h3><a name="2.5">2.5 Keep your test fixture simple</a></h3>


<h4>Short Description</h4>

<p>If the test fixture becomes too large and incoherent, split the test into multiple smaller tests.  As
names for these extra test classes, use &lt;class name&gt; + &lt;description of tested behavior&gt; + <i>‘Test’.</i></p>


<h4>Description</h4>

<p>Grouping too many (incoherent) tests in the same test class can cause a test fixture to become too large and incoherent. If this 
is the case, split up the test fixture by dividing the test methods over multiple test classes. Because test data is put in instance 
variables (See <a href="#2.4">Create test data during setup</a>) you can easily spot incoherent test classes: they contain lots of instance 
variables that are only used by some of the test methods.</p>

<p>Try to find a logical group of test methods and move them to a new test class. Name this new test class as follows: the original 
test class name, followed by some word that says something about the new group followed by ‘Test’.</p>


<h4>Examples</h4>

<p>Suppose you have a test class for a class named UserAdmin
that contains code for maintaining users and their roles.</p>

<div class="source"><pre>
public class UserAdminTest extends TestCase {

    /* A simple test user 1 */                              <span class="code-comment">//</span>
    private User user1;                                     <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    /* A simple test user 10 */                             <span class="code-comment">// Test Data (Fixture)</span>
    private User user10;                                    <span class="code-comment">//  that is too large</span>
                                                            <span class="code-comment">//</span>
    /* An administrator role 1 */                           <span class="code-comment">//</span>
    private Role adminRole1;                                <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    /* An administrator role 10 */                          <span class="code-comment">//</span>
    private Role adminRole10;                               <span class="code-comment">//</span>


    /**
     * Test for method with …
     */
    public void testAddUser1() {
    }

    /**
     * Test for method with …
     */
    public void testAddRole1() { 
    }

    ...
}
</pre></div>

<p>This class clearly contains a fixture that is too large, so we should split the test class into multiple test classes. We could 
for example create a new class named UserAdmin<b>Roles</b>Test and move all roles related tests and test data out of the 
UserAdminTest class to this new class.</p>

<div class="source"><pre>
public class UserAdminTest extends TestCase {

    /* A simple test user 1 */                              <span class="code-comment">//</span>
    private User user1;                                     <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">// User Test Data (Fixture)</span>
                                                            <span class="code-comment">//</span>
    /* A simple test user 10 */                             <span class="code-comment">//</span>
    private User user10;                                    <span class="code-comment">//</span>


    /**                                                     <span class="code-comment">//</span>
     * Test for method with …                               <span class="code-comment">//</span>
     */                                                     <span class="code-comment">//</span>
    public void testAddUser1() {                            <span class="code-comment">// User Tests</span>
    }                                                       <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">//</span>
}

public class UserAdminRolesTest extends TestCase {

    /* An administrator role 1 */                           <span class="code-comment">//</span>
    private Role adminRole1;                                <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">// Roles Test Data (Fixture)</span>
                                                            <span class="code-comment">//</span>
    /* An administrator role 10 */                          <span class="code-comment">//</span>
    private Role adminRole10;                               <span class="code-comment">//</span>


    /**                                                     <span class="code-comment">//</span>
     * Test for method with …                               <span class="code-comment">//</span>
     */                                                     <span class="code-comment">//</span>
    public void testAddRole1() {                            <span class="code-comment">// Roles Tests</span>
    }                                                       <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
    ...                                                     <span class="code-comment">//</span>
}
</pre></div>

</div>




<div class="section"><h3><a name="2.6">2.6 Test boundary conditions</a></h3>


<h4>Short Description</h4>

<p>Write tests for all boundary conditions of the tested method.
Only boundary conditions that a method can handle according to its interface
(javadoc and arguments) should be tested.</p>

<p><i>For every boundary condition do the following:</i></p>

<ul>
    <li><p>write a unit test for this boundary condition or</p></li>
    <li><p>add a preconditions to the javadoc that excludes this condition from the method’s contract.</p></li> 
</ul>


<h4>Description</h4>

<p>You should test the interface of the method. If a method’s
interface (javadoc and arguments) does not prohibit a boundary value such as null,
the method should be able to handle it.</p>

<p>If the method shouldn’t be called with some boundary value:
change the signature. That is, put the constraint as precondition in the
javadoc of the method. This could be as easy as adding <i>not null</i> to the
parameter declaration in the javadoc.</p>

<p>If the method allows boundary values: create test cases for
these values. Following table shows the typical boundary values for which you
should write a test.</p>

<table>
    <tr><td><b><i>Argument</i></b></td>     <td><b><i>Boundary conditions</i></b></td></tr>
    <tr><td>Object</td>                     <td><b>null</b></td></tr>
    <tr><td></td>                           <td><b>boundary conditions of instance variables</b></td></tr>
    <tr><td>Numeric value</td>              <td><i>0</i></td></tr>
    <tr><td></td>                           <td><i>negative value</i></td></tr>
    <tr><td></td>                           <td><i>minimum and maximum</i></td></tr>
    <tr><td>String</td>                     <td><b>null</b></td></tr>
    <tr><td></td>                           <td><i>empty string</i></td></tr>
    <tr><td></td>                           <td><i>length equal to maximum length (if maximum defined)</i></td></tr>
    <tr><td></td>                           <td><i>length greater than maximum length (if maximum defined)</i></td></tr>
    <tr><td>Collections</td>                <td><b>null</b></td></tr>
    <tr><td></td>                           <td><i>empty collection</i></td></tr>
    <tr><td></td>                           <td><i>collection with duplicate elements</i></td></tr>  
</table>

<p>The bold conditions are the minimal conditions for which a test needs to be written. Add extra boundary condition 
tests when necessary. For example, you should create tests for the length of a string argument when the method implementation 
has some kind of restriction on the length of a string.</p>

<p>Exception boundary conditions should also be tested. How to test such conditions is described in <a href="#2.18">Test declared exceptions</a>.</p>


<h4>Examples</h4>

<p>Suppose you have a class named UserAdmin that defines a method for adding a user. This method takes two arguments: a user and a role.</p>

<div class="source"><pre>
public class UserAdmin
{

    /**
     * Adds a user and links it to the given role.
     *
     * @param user the user to add
     * @param role the user’s role
     */
     public void addUser(User user, Role role) {        
        users.add(user.getName());
        roles.put(role.getName(), user)
    }
}
</pre></div>

<p>After writing the tests for the typical behavior of this method, we should also add test for the boundary conditions of the 
arguments. Note that the method’s javadoc doesn’t mention that the method cannot be called with null arguments.</p>

<p>You should now either, add the proper preconditions to the javadoc…</p>

<div class="source"><pre>
public class UserAdmin
{

    /**
     * Adds a user and links it to the given role.
     *
     * @param user the user to add, not null                <span class="code-comment">// Extra precondition</span>
     * @param role the user’s role
     */
     public void addUser(User user, Role role) {
        users.add(user.getName());
        roles.put(role.getName(), user)
     }
}
</pre></div>

<p>…or write a proper boundary condition test.</p>

<div class="source"><pre>
public class UserAdminTest extends TestCase {

    /**
     * Test for method for a null role argument.
     */
    public void testAddUser_nullRole() {
        userAdmin.addUser(user, null);                      <span class="code-comment">// Boundary cond. test</span>

        //validate result
        ... 
    }
}

</pre></div>

<p>If you look at the implementation of the method, you see that this test will fail initially. You should fix the bug by implementing 
the proper null handling in the method and then rerun the test until it's successful.</p>

</div>




<div class="section"><h3><a name="2.7">2.7 Test public interface, not internals</a></h3>


<h4>Short Description</h4>

<p>Only test the behavior as is described in the public interface and javadoc. The internal implementation should not be tested. Do not 
test trivial methods such as getters and setters. Only methods that contain logic should be tested. Only test protected methods if 
they are meant to be called directly by subclasses, for example utility methods in abstract base classes.</p>


<h4>Description</h4>

<p>The public interface of a class defines the behavior of the class. How a certain behavior is implemented is not important. 
Your tests should therefore not depend on how a class is implemented. Only testing the interface will make your tests less 
sensitive to change and refactorings. It will minimize the changes needed to your tests when changes to the implementation are made.</p>

<p>Tests should be written for all methods that contain some non-trivial logic. Trivial methods that contain no logic, such as simple getters
and setters, should not be tested. These tests would give no added-value and would only increase the effort needed to maintain all tests.</p>


<h4>Examples</h4>

<p>Suppose you have following class, containing a non-trivial public method, a non trivial getter, a trivial setter and an 
internal implementation method.</p>

<div class="source"><pre>
public class User {
      

    /**
     * Adds a new role, the guest role will be added if user is null.
     *
     * @param role the role to add, null for guest role
     */
    public void addRole(Role role) {
        if (role == null) {
            role = createRole(“guest”);
            roles.add(role);
        }
    }


    /**
     * Getter for the age field.
     *
     * @return the age in years
     */
    public int getAge(){                                    <span class="code-comment">//</span>
                                                            <span class="code-comment">//</span>
        // calculate age using birth date                   <span class="code-comment">// Non trivial getter</span>
                                                            <span class="code-comment">//</span>
        return age;                                         <span class="code-comment">//</span>
    }                                                       <span class="code-comment">//</span>


    /**
     * Setter for birthDate field.
     *
     * @param birthDate the date, not null
     */
    public void setBirthDate(Date birthDate){               <span class="code-comment">//</span>
        this.birthDate = birthDate;                         <span class="code-comment">// Trivial setter</span>
    }                                                       <span class="code-comment">//</span>


    /**
     * Factory method: creates a new role with the 
     * given name.
     * 
     * @return the role
     */
    protected Role createRole(String roleName) {            <span class="code-comment">//</span>
        return new Role(roleName);                          <span class="code-comment">// Non-public method</span>
    }                                                       <span class="code-comment">//</span>
}
</pre></div>

<p>In this example you should only write tests for the addRole() and getAge() method since these contain real logic. Testing the trivial
setBirthDate() method would have no added-value. The createRole() method is used for the internal implementation and should therefore not 
be tested on its own. It will be tested during the addUser() test.</p>

<p>Following code snippets show an example of why you shouldn’t test the internals of a class.</p>

<div class="source"><pre>
public class UserAdmin
{      
    private Map userMap = new HashMap();

    /**
     * Adds a new user.
     *
     * @param user the user to add<b>, </b>not null
     */
    public void addUser(User user) {
        userMap.add(user.getSsn(), user);
    }


    /** 
     * Getter for user map.
     *
     * return the map
     */
    public Map getUserMap(){
        return userMap;
    }
}
</pre></div>

<p>Suppose you would create a test for addUser() as follows:</p>

<div class="source"><pre>
public class UserAdminTest extends TestCase {

    /**
     * Test for method for addUser.
     */
    public void testAddUser() {
        userAdmin.addUser(user);
        
        //validate result
        Map userMap = userAdmin.getUserMap();               <span class="code-comment">// Implementation detail</span>
        User result = userMap.get(“my ssn”);  
        ReflectionAssert.assertLenEquals(user, result);
    }
}
</pre></div>

<p>You should avoid writing tests that depend on the implementation details of the class. In the example above, suppose you would
want to change to use the username as key in the map instead of the SSN, you would need to change all your tests.</p>

</div>




<div class="section"><h3><a name="2.8">2.8 Keep test methods small</a></h3>


<h4>Short Description</h4>

<p>Keep your test code as simple as possible. It should only contain:</p>

<ul>
    <li><p>an optional <i>small</i> setup of test data</p></li>
    <li><p>the actual test call</p></li>
    <li><p>a <i>limited</i> number of assertions</p></li>
</ul>


<h4>Description</h4>

<p>Tests should only contain the minimal amount of code needed to perform the test. This will keep your tests simple and maintainable.
Only write assertions and data setup if they are really of value for your tests. There is no added-value in writing an assertion for a
field value if the function of the test method is to test another field value.</p>

<p>Unitils’ ReflectionAssert can aid in only comparing values that are important for the test. It uses reflection to see whether 2 objects
contain the same values (See <a href="#2.11">Use reflection for equality checking</a>). It can however also be configured to perform a more
lenient comparison: for example, it can ignore fields that contain default values are can ignore ordering in collections.</p>


<h4>Examples</h4>

<div class="source"><pre>
public class UserTest extends TestCase {

    /**
     * Test method for setting the age.
     */
    public void testSetAge() {
        user.setName(“john”);                               <span class="code-comment">// Useless setup</span>
        
        user.setAge(50);

        assertEquals(50, user.getAge());
        assertEquals(“john”, user.getName());               <span class="code-comment">// Useless assertion</span>
    }
}
</pre></div>

<p>There is no reason for testing the name functionality in this test for the setting of the age. The code in this test should be limited
to the testing of the age. This will make the test more maintainable because it is no longer dependent on the naming functionality and changes 
to this functionality will not cause changes in this test.</p>

</div>





<div class="section"><h3><a name="2.9">2.9 Create independent unit tests</a></h3>


<h4>Short Description</h4>

<p>A unit test should not depend on the outcome of another unit test. All tests should be independent of each other. One should be able to run
each of the tests on its own.</p>


<h4>Description</h4>

<p>The particular sequence in which the test methods will be called is not guaranteed. The tests should therefore never rely on any execution
sequence and should contain all setup that is needed to perform the test.</p>


<h4>Examples</h4>

<div class="source"><pre>
public class UserTest extends TestCase {
    
    /**
     * Test method for adding a user.
     */
    public void testAddUser() {        
        userAdmin.addUser(user);
        
        assertEquals(user,userAdmin.getUser(“user”));
    }
    
    
    /**
     * Test method for removing a user.
     */
    public void testRemoveUser() {        
        userAdmin.addUser(user);                            <span class="code-comment">// Extra setup</span>
        
        userAdmin.removeUser(user);
        
        assertNull(userAdmin.getUser(“user”));
    }
}
</pre></div>

<p>The remove user test should not depend on the add user test to get the database in a certain state but should include its own set up.</p>

</div>





<div class="section"><h3><a name="2.10">2.10 Write tests while writing code</a></h3>


<h4>Short Description</h4>

<p>Writing tests should be done while you are writing your code not afterwards.</p>


<h4>Description</h4>

<p>When you are writing code, you have to test it one way or another. So why not write a unit test directly? Testing your code through the 
user interface is often difficult because the necessary test data is not available or certain boundary conditions are difficult to simulate.</p>

<p>Some people prefer writing tests <i>before</i> writing the actual code. They start with writing the interface of the method, then write a
few test for the functionality (that of course fail at that moment, because there is no code yet) and then implement the method until all tests 
succeed. If needed extra tests are added during the implementation. While this approach is very viable, not everyone likes to code this way. We 
just advise you to write your test code at least while you are writing the code. In other words, the implementation is not completely finished 
if there is no unit test.</p>

<p>You can start with writing tests for the main execution paths of the method and then when the implementation is stable, add extra
boundary condition and alternative flow tests. With these guidelines, the utility code and some practice, writing unit tests should become very 
simple. There is no reason in not doing unit testing.</p>

</div>





<div class="section"><h3><a name="2.11">2.11 Use reflection for equality checking</a></h3>


<h4>Short Description</h4>

<p>Use reflection to check equality instead of equals() method. As a consequence, you should avoid using the assertEquals() and assertSame()
methods for object types other that basic types such as String, Integer etc.</p>


<h4>Description</h4>

<p>Equals methods can contain business logic and should therefore not be used to test whether all inner values are equal. </p>

<p>An equals() method of a user object can for example be implemented to return true when they have the same social security number. If
you would use assertEquals() on 2 user instances you would therefore only test the equality of the social security number and not the equality 
of any of the other fields. Instead of using the equals() method, you should compare each of the field values one by one. This can be done by accessing 
the field values through their getter methods (if the field has one) and then comparing the values directly. Doing this manually however 
would require lots of coding and is very error-prone. It’s better to do this automatically by using reflection.</p>

<p>We already implemented a utility class that does this for you: <i>ReflectionAssert</i>.</p>

<p><i>ReflectionAssert</i> will run through the fields of the instances using reflection and compare each of the field values one by one. If
a field value is again an object instance, all its fields will recursively be compared in the same way. The ReflectionAssert class also offers functionality 
for non-strict comparison of fields. You can for example only compare field values if the field does not contain a default Java value or test whether a 
collection contains some values but not necessarily in the same order. This makes it possible to only compare what is realy important for the 
test (See <a href="#2.8">Keep test methods small</a>).</p>


<h4>Examples</h4>

<div class="source"><pre>
public class User {

    /* The social security number */
    private String ssn;

    /* The last name of the user */
    private String name;

    
    /**
     * Test whether the given object is the same user.
     */   
    public boolean equals(Object object) {        
        if (!(object instanceof User)) {
            return false;
        }
        
        User user = (User) object;                          <span class="code-comment">//</span>
        if (ssn == null &amp;&amp; user.ssn == null) {              <span class="code-comment">//</span>
            return true;                                    <span class="code-comment">// Business logic</span>
        }                                                   <span class="code-comment">//</span>
        return (ssn != null &amp;&amp; ssn.equals(user.ssn))        <span class="code-comment">//</span>
    }



user1.ssn  = 111          
user2.ssn  = 111        

user1.name = John             
user2.name = Tom

assertEquals(user1, user2)                      <b>true</b>
ReflectionAssert.assertEquals(user1, user2)     <b>false</b>
</pre></div>

</div>





<div class="section"><h3><a name="2.12">2.12 Everyone tests or no one tests</a></h3>


<h4>Short Description</h4>

<p>Whether or not to perform unit-testing should be decided on a project level. </p>


<h4>Description</h4>

<p>The unit testing strategy that you adopt in your team has great impact. It should be fully adopted and supported by everyone; there is no
use in some intermediate level. If you don’t go for it all-the-way, you will eventually end up writing or running no unit tests at all. </p>

<p>Why doesn’t it make sense when some of your team members are into unit testing and some don’t? Because members that do write them will
constantly be annoyed when others change their code and don’t maintain the tests, or by having to write unit tests for untested code of somebody 
else when changing it. In the end, they will also give up their good efforts and stop writing unit tests.</p>

<p>The best way to get everyone to write unit-tests is to convince the project manager of the necessity of such tests and let him impose
the writing of the tests on a project level. </p>

</div>





<div class="section"><h3><a name="2.13">2.13 Fix broken tests immediately</a></h3>


<h4>Short Description</h4>

<p>When a test is broken, fix it as soon as possible. </p>


<h4>Description</h4>

<p>The goal should be to keep the test bar green as much as possible. This motivates people to write descent and working tests. If you
break some test, fix the test yourself immediately and don’t pass the duty on to someone else.</p>

<p>If a test cannot be fixed in a reasonable period of time, disable the test. You can do this by commenting the test implementation and
putting some logging statements in place to make sure you won’t forget to re-enable it when it becomes possible.</p>

</div>





<div class="section"><h3><a name="2.14">2.14 Use continuous integration</a></h3>

<h4>Short Description</h4>

<p>Only run the tests of the code that you’re working on. Let a continuous build system perform the other tests.</p>


<h4>Description</h4>

<p>Manually running all of the tests over after each code change is a time-consuming task. Only run the tests that have something to do
with the code that you are writing and let an automatic build system run the other tests. Typically you would only run the tests that are 
linked to the class in which you have written your code. E.g. if you changed something in the User class, perform all tests on the User*Test classes.</p>

<p>The continuous build server should be configured to run all unit-tests after code change and immediately give feedback when somebody broke
a test. Impose your developers to immediately try to fix the build when it is broken. (See <a href="#2.13">Fix broken tests immediately</a>)</p>

</div>




<div class="section"><h3><a name="2.15">2.15 Use build tool or IDE to run suites of tests</a></h3>


<h4>Short Description</h4>

<p>Do not use JUnit’s TestSuite to bundle sets of your tests. Use a build tool such as Ant or an IDE to run such sets instead.</p>


<h4>Description</h4>

<p>JUnit offers the possibility to create a set of tests by adding them to a test suite. You could for example add every test in a package
to such a suite so that they can all be performed at a single run. Manually maintaining such suites however is asking for trouble. For 
example, each time you have created a new test-class, you have to manually add it to the test-suite. If you forget to do this the tests 
will not be performed when the suite is run.</p>

<p>Build tools like ant and IDEs like Eclipse and IntelliJ can automatically create test suites for you, so that you are sure that 
every test is being performed.</p>


<h4>Examples</h4>

<p>Ant build-script for running all your tests in your test source folder:</p>

<div class="source"><pre>
&lt;junit printsummary=&quot;yes&quot; haltonfailure=&quot;true&quot;&gt;

    &lt;classpath&gt;
        &lt;pathelement path=&quot;${project.classpath.junit}&quot;/&gt;
    &lt;/classpath&gt;

    &lt;formatter type=&quot;xml&quot;/&gt;
    &lt;batchtest fork=&quot;yes&quot; todir=&quot;${project.build}/test&quot;&gt;
        &lt;fileset dir=&quot;${project.source.test}&quot;&gt;
            <b>&lt;include name=&quot;**/*Test.java&quot;/&gt;</b>
        &lt;/fileset&gt;
    &lt;/batchtest&gt;

&lt;/junit&gt;
</pre></div>

</div>





<div class="section"><h3><a name="2.16">2.16 Write test when fixing a bug</a></h3>


<h4>Short Description</h4>

<p>If you fix a bug, also write a test for the fix. </p>


<h4>Description</h4>

<p>Unless you achieve 100% test-coverage, i.e. test every possible line of the code, it will always be possible that there are bugs left
in the code. These bugs will typically be intercepted at a later test-stage, such as during the functional testing.</p>

<p>When a bug is found and the code is altered to fix it, also write a unit test for this fix. You have to test it anyway, so why not writing
a unit test. Furthermore this will make sure that the bug will not be re-introduced in the code at a later time (regression test).</p>

</div>





<div class="section"><h3><a name="2.17">2.17 Test new project code, not library code</a></h3>


<h4>Short Description</h4>

<p>Only test code that is being written or changed. Do not write tests for libraries or non-project code.</p>


<h4>Description</h4>

<p>Unit tests should test code that is written on the project, not the code of libraries or external packages. These libraries should have
their own test suite. If you doubt whether a certain library functions correctly, write a separate test specifically for this library. Do not test the
functionality from your projects unit tests.</p>

</div>





<div class="section"><h3><a name="2.18">2.18 Test declared exceptions</a></h3>


<h4>Short Description</h4>

<p>Write tests for exceptional conditions that are declared in the interface.</p>


<h4>Description</h4>

<p>Functional exceptional conditions are boundary conditions that should be tested in a unit-test. This can be done by triggering the exceptional
condition in a try-catch block and calling fail if the expected exception is not thrown (see below for an example).</p>

<p>Test methods that are not actually testing this exceptional boundary condition should not add such a try-catch but just add a throws
Exception clause to the test. Exceptional conditions that arise because of a bug in the code, e.g. NullPointerException, or because of some unexpected 
problem, e.g. IOException, should not be handled in the unit test. Let JUnit or TestNG handle these exceptions.</p>


<h4>Examples</h4>

<div class="source"><pre>
public class UserTest extends TestCase {

    /**
     * Test method for setting the age.
     */
    public void testSetAge() throws Exception {             <span class="code-comment">// No try-catch for</span>
                                                            <span class="code-comment">// NegativeAgeException</span>
        user.setAge(50);

        assertEquals(50, user.getAge());
    }

    /**
     * Test method for setting the age.
     */
    public void testSetAge_negative() {       
        try {
            user.setAge(-1);
            fail("Epected NegativeAgeException.");          <span class="code-comment">// No exception, so fail</span>
            
        } catch (NegativeAgeException e) {
            //expected                                      <span class="code-comment">//</span>
        }                                                   <span class="code-comment">// Expected flow</span>
                                                            <span class="code-comment">//</span>
        assertEquals(20, user.getAge());                    <span class="code-comment">//</span>
    }
}
</pre></div>

</div>







<br />
<h2><a name="3">3. Database testing guidelines</a></h2>

<p>The database layer is a very important though brittle layer. Since the database layer is implemented at two different levels (DAO layer +
database itself), bugs occur frequently because of mismatches between these two. To spot problems in the persistence layer instantly, unit tests 
should be written for the persistence layer as a whole (DAO layer + database itself). DBUnit (<a href="http://dbunit.sourceforge.net/">http://dbunit.sourceforge.net/</a>) 
is used as supporting technology.</p>



<div class="section"><h3><a name="3.1">3.1 Test with unit test databases</a></h3>


<h4>Short Description</h4>

<ul>
    <li><p>Write your database tests on a unit test database. A unit test database contains only database structure, no data.</p></li>
    <li><p>Give each developer a separate unit test database instance or schema.</p></li>    
</ul>


<h4>Description</h4>

<p>Unit tests should not require a database filled with test data. If they depend on existing data, it becomes very difficult to make changes to 
this data without causing other tests to break. Developers will therefore rather add new data than changing existing records. As more data is added to
the database, this situation becomes more and more difficult to maintain.</p> 

<p>We need to have complete control over the database structure and test data for each test individually. This can be realized by using a unit 
test database containing only the database structure and no data. Every unit test will then insert a small set of test data before running the test
(See <a href="#3.7">Keep your test data files simple</a>).</p>

<p>To avoid that different developers interfere with each other when executing unit tests, each developer should be given a separate database instance 
or schema (See <a href="#3.2">Automate the maintenance of the test databases</a>). These instances or schemas will contain little or no data and can 
therefore easily be installed on a shared server or could also be created as an extra schema on the existing development database.</p>


<h4>Examples</h4>

<p>The following schema represents a team with 3 developers. Every developer has an own unit test database schema. The continuous build server, in this 
case Cruise Control, is also configured to run on a separate UNIT_CRCO schema.</p>

<p>All the test databases are extra schemas that have been added to the development database.</p>

<div class="image-center"><img src="images/schema_per_user.png" /></div>


</div>





<div class="section"><h3><a name="3.2">3.2 Automate the maintenance of the test databases</a></h3>


<h4>Short Description</h4>

<p>The maintenance of test databases should be automated as much as possible. This can be done in one of following ways:</p>

<ul>
    <li><p>Use Unitils’ DBMaintainer for automatic, incremental maintenance.</p></li>
    <li><p>Write a tool or shell script for executing a DDL script on every unit test database after each database change.</p></li>
    <li><p>Maintain a full DDL script and re-create the unit test schemas from scratch after every database change.</p></li>
</ul>

<h4>Description</h4>

<p>A lot of time can be saved by automating the maintenance of databases in general and unit test schemas in particular. Following are some
good approaches:</p>

<p><b><i>Use Unitils’ DBMaintainer</i></b> - Every database schema keeps track of a version number. Changes to the database are made by creating an 
update DDL script with a version number in the filename. When running unit tests, the DBMaintainer will automatically check for
availability of update files and invoke them on the database. Look at the documentation of Unitils for more information.</p>

<p><i><u>Advantages</u></i>: This is a very simple approach that completely automates the schema maintenance, almost without noticeable delays 
because of the incremental updates. This also works perfectly with a VCS: when a developer performs an update of his codebase he will receive 
update scripts along with the corresponding changes to the code. When a test is run, these new scripts will be executed on the database, so code 
and database structure will always be in synch. Another advantage is that maintenance happens in a decentralized way, allowing developers to use 
a local test database, for example, when working on separate locations or at home.</p>

<p><b><i>Use a distribution script</i></b> - This is a similar approach. Every time a change occurs on the project database, the corresponding
DDL is provided to a shell script or tool that executes it on all of the unit test databases. The person that performs the database change also 
has to run the distribution script.</p>

<p><i><u>Advantages</u></i>: Database updates are immediately available for every developer.</p>
<p><i><u>Disadvantages</u></i>: Mistakes are more difficult to fix and someone needs to execute and manage all of the database update scripts.</p>

<p><b><i>Maintain a full DDL script</i></b><i> -</i> Instead of creating incremental scripts, all changes are added to a DDL script that can
create the full database from scratch. Every time a change occurs to the project database, the unit test databases are recreated from scratch using this
full DDL script. Make sure that this script is executed automatically on every unit test database when it is changed.</p>

<p><i><u>Advantages</u></i>: It's clean and simple.</p>
<p><i><u>Disadvantages</u></i>: A major drawback is that, when the database size grows, maintaining a full DDL script will become much more difficult 
and performing a clean database setup will take a considerable amount of time.</p>
</div>





<div class="section"><h3><a name="3.3">3.3 Disable foreign key and not null constraints</a></h3>


<h4>Short Description</h4>

<p>Disable all foreign key and not null constraints in unit testing databases. This way, no more test data has to be inserted than required 
for the test. Automate the disabling process to reduce the burden of manual maintenance.</p>


<h4>Description</h4>

<p>Database unit tests have to be written with as few test data as possible. In this context, database constraints do more harm than good. Disabling 
foreign key and not null constraints makes sure we only have to insert the data that we need for the test, nothing more.</p>

<p>To reduce the burden and avoid forgetting it, the disabling of constraints should be automated. Unitils’ DBMaintainer will automatically disable 
all constraints after it performs an update to the database.</p>


<h4>Examples</h4>

<p>Suppose we have an application with users that have a role, are member of an organization and have multiple email addresses:</p>

<div class="image-left"><img src="images/tables1.png" /></div>

<p>A test data set for a method that retrieves the email addresses for a user could be written as follows:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;dataset&gt;

    &lt;user id=&quot;1&quot; username=&quot;jdoe&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@gmail.com&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@post.be&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

<p>This data file contains all data we need for our unit test. If we would work with a unit test database with all constraints 
enabled, some extra records that are not relevant for the test need to be added to the data set:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;

&lt;dataset&gt;

    &lt;user id=&quot;1&quot; username=&quot;jdoe&quot; name=&quot;Doe&quot; roleid=&quot;1&quot; companyid=&quot;1&quot; /&gt;

    &lt;role id=&quot;1&quot; rolename=&quot;admin&quot; /&gt;
    &lt;company id=&quot;1&quot; name=&quot;Ordina&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@gmail.com&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@post.be&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

<p>The presence of constraints not only makes us spend a lot more time writing data, but also the maintenance cost increases dramatically.
For example, if a new NOT NULL column is added to one of the tables, the data file must be changed, even though it has no impact on the actual test.</p>

</div>





<div class="section"><h3><a name="3.4">3.4 Testing simple CRUD methods</a></h3>


<h4>Short Description</h4>

<p>Unit tests for CRUD methods are very simple and all follow a similar structure. When using Hibernate or JPA (EJB3 Persistence), testing
simple CRUD methods is not useful.</p>


<h4>Description</h4>

<p>Unit tests for read, create, update and delete methods are very simple and share a similar structure.</p>

<p>Result-check data files (see <a href="#3.6">Testing bulk data manipulation methods</a>) should not be used for checking if 
a create, update or delete method behaves as expected. This can be done very simply by using the interface of the DAO and the ReflectionAssert 
class. The examples show how these methods can be tested in a simple way.</p>


<h4>Examples</h4>

<p>Simple CRUD methods can be tested easily through the interface of the DAO. Here are for example the unit tests for the findById,
create, update and delete methods of the UserDAO class:</p>

<div class="source"><pre>
@DataSet
public class UserDaoTest extends BaseDAOTest {
    
    protected void setUp() throws Exception {
        newUser = new User(“john”, "doe");
    }
    
    
    public void testCreate() {
        userDao.create(newUser);
        User toVerify = userDao.findById(user.getId());
    
        ReflectionAssert.assertRefEqual(user, toVerify);
    }
    
    
    public void testUpdate() {
        User user = userDao.getUser(1);
        user.setName(“testUpdated”);
    
        userDao.update(user);
        User toVerify = userDao.findById(user.getId());
    
        ReflectionAssert.assertEquals(user, toVerify);
    }
    
    
    public void testDelete() {
        userDao.delete(existingUser);
        User toVerify = userDao.findById(existingUser.getId());
    
        assertNull(toVerify);
    }    
}
</pre></div>

<p>We have used following data file:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;dataset&gt;

    &lt;user id=&quot;1&quot; first=”jim” last="smith" /&gt;

&lt;/dataset&gt;
</pre></div>

<p>A separate test for findById() is not included. The correct behavior of this method is implicitly tested by the other test methods.</p>

</div>





<div class="section"><h3><a name="3.5">3.5 Testing queries</a></h3>


<h4>Short Description</h4>

<p>SQL or HQL are often complex and difficult to maintain. Writing unit tests for these queries is therefore very important, especially
for complex queries. Following the rules in the description helps you in writing simple but effective tests for these queries.</p>


<h4>Description</h4>

<p>Unit tests can be most effective for guaranteeing the correctness of a query, expecially for complex queries. It can also prove invaluable 
for making sure that changes to the database did not brake any of the other queries.</p>

<p>Following steps can be performed when writing a unit test for a query:</p>

<ul>
    <li><p>Create a test data set with one or a few records that should be included in the result of the query.</p></li>
    <li><p>Add one or a few records to these file that should not be included in the result of the query.</p></li>
    <li><p>For each of these records only add the key columns and the columns involved in join conditions and where clauses.</p></li>
    <li><p>Write a test that invokes the query method.</p></li>
    <li><p>Assert that the result is correct by comparing the returned key fields of the result with the expected record keys.</p></li>
</ul>

<p>We create a dataset so that we're able to test the expected query results. In this data set we also add records to test whether the query does 
not return more than is expected, for example, because of a missing where clause. We make sure to only add data that is actually required for testing 
the query, i.e. the join conditions and where clauses. This will keep your datasets as small and maintainable as possible 
(See <a href="#3.7">3.7 Keep your test data files simple</a>). The same is true for checking the result: we only use ids to check whether the 
correct results are returned (See <a href="#2.8">2.8 Keep test methods small</a>).</p>



<h4>Examples</h4>

<p>The example shows a unit test for a query on a database that has following structure:</p>

<div class="image-left"><img src="images/tables2.png" /></div>

<p>Every user belongs to exactly one company. Companies can have a number of partnerships with other companies. The DAO method under 
test, findPartnershipUsers, returns a List of all users that belong to a company that have some kind of partnership with the given company.</p>

<div class="source"><pre>
public List&lt;User&gt; findPartnershipUsers(Company comp) {
    String query = &quot;select u.id, u.username, u.name, u.fname, u.roleid, u.company &quot;  
                   &quot;from user u, company c1, company c2, partnership p &quot; +
                   &quot;where u.companyid = c1.id &quot; +
                   &quot;  and p.company1id = c1.id &quot; +
                   &quot;  and p.company2id = c2.id &quot; +
                   &quot;  and c2.name = ?&quot;;    
    return invokeQuery(query);
}
</pre></div>

<p>We’ve written following unit test:</p>

<div class="source"><pre>
public void testFindPartnershipUsers() {
    List&lt;User&gt; foundUsers = userDao.findPartnershipUsers("MyCompany");
    ReflectionAssert.assertPropertyLenEquals("id", Arrays.asList(2), foundUsers);      
}
</pre></div>

<p>with this data file:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;dataset&gt;
    
    &lt;company id=&quot;1&quot; name=&quot;MyCompany&quot; /&gt;
    &lt;user id=&quot;1&quot; companyid=&quot;1&quot; /&gt;

    &lt;company id=&quot;2&quot; /&gt;    
    &lt;user id=&quot;2&quot; companyid=&quot;2&quot; /&gt;
    
    &lt;company id=&quot;3&quot; /&gt;
    &lt;user id=&quot;3&quot; companyid=&quot;3&quot; /&gt;
    
    &lt;partnership company1id=&quot;1&quot; company2id=&quot;2&quot; /&gt;
    &lt;partnership company1id=&quot;2&quot; company2id=&quot;3&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

<p>The data file defines 3 users, the first one being member of MyCompany, the second is member of a second company, which has a
partnership with MyCompany. The third user is member of company 3, which is a partner of company 2, but not a partner of MyCompany. 
Only the second user should be returned by the tested method, we therefore check whether the id of the returned user is equal to 2.</p>

</div>




<div class="section"><h3><a name="3.6">3.6 Testing bulk data manipulation methods</a></h3>


<h4>Short Description</h4>

<p>For testing bulk insert, update or delete methods, which are cumbersome to test through the API of your DAOs, check the updated DB contents
with a DBUnit result data file.</p>


<h4>Description</h4>

<p>Database methods that do collective updates or deletes are often difficult to test. These methods are in most cases written as calls to
stored procedures in the database or as SQL or HQL statements with a complex ‘where’-clause. Verifying correctness of these methods through the interface of
a DAO and with regular assert methods, is often cumbersome.</p>

<p>Unitils' <i>ExpectedDataSet</i> can be used to check the result of a test by comparing the contents of the database with a result data file. 
Only the tables and columns that you actually want to check should be included in the data file.</p>

<p>Result data files are very powerful: you can check almost anything with a simple XML file. They should however not be overused. When doing
database updates, a number of data files will also have to be updated. The more data files you have, the more impact database refactorings will have.
When possible, try to test the result through the interface of you DAO.</p>

<p>Make sure everything is commited on the database. For example, when you make use of Hibernate, make sure you flush the Hibernate 
session before you check the content of the database. If Unitils manages the Hibernate sessions, this will automatically be done for you.</p>


<h4>Examples</h4>

<p>Suppose you have a system in which users can place orders. A weekly batch job moves all orders that are older than a year to a history table. 
This history table cannot be queried by the application, but we keep the information for statistical reporting purposes. The batch job is
implemented using a call to a stored procedure. We have following table structure:</p>

<div class="image-left"><img src="images/tables3.png" /></div>

<p>In our application, nothing is foreseen for querying the archive tables. It is therefore a good idea to use a result data file to verify
the correct behavior of this stored procedure. Our unit test looks like the following:</p>

<div class="source"><pre>
@ExpectedDataSet
public void testArchiveOrders() {
    orderDao.archiveOrdersOlderThan(DateUtils.parseDate(&quot;21-05-2005&quot;);
    assertMatchesResultDataset(); 
}
</pre></div>

<p>And we have following data file:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;dataset&gt;

    &lt;order id=&quot;1&quot; date=&quot;20-05-2005&quot; /&gt;
    &lt;orderline id=&quot;11&quot; orderid=&quot;1&quot; /&gt;
    &lt;orderline id=&quot;12&quot; orderid=&quot;1&quot; /&gt;

    &lt;order id=&quot;2&quot; date=&quot;21-05-2005&quot; /&gt;
    &lt;orderline id=&quot;21&quot; orderid=&quot;2&quot; /&gt;
    &lt;orderline id=&quot;22&quot; orderid=&quot;2&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

<p>For verification following data set is used:</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;dataset&gt;

    &lt;order id=&quot;2&quot; /&gt;
    &lt;orderline id=&quot;21&quot; /&gt;
    &lt;orderline id=&quot;22&quot; /&gt;

    &lt;arch_order id= &quot;1&quot; date=&quot;20-05-2005&quot; /&gt;
    &lt;arch_orderline id=&quot;11&quot; arch_orderid=&quot;1&quot; /&gt;
    &lt;arch_orderline id=&quot;12&quot; arch_orderid=&quot;1&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

</div>





<div class="section"><h3><a name="3.7">3.7 Keep your test data files simple</a></h3>


<h4>Short Description</h4>

<ul>
    <li><p>Use DBUnit’s <a href="http://www.dbunit.org/apidocs/org/dbunit/dataset/xml/FlatXmlDataSet.html">FlatXMLDataSet</a> format for your data files</p></li>
    <li><p>Add no more data than necessary. Only fill ID columns, join condition columns and where condition columns.</p></li>
    <li><p>When data files grow too large or become incoherent, split your class in multiple test classes or create method-specific data files.</p></li>
</ul>


<h4>Description</h4>

<p>Putting test data in data files makes your unit test dependent on the database structure. Each time a change occurs to an existing
database column, a number of files need to be changed. Your unit tests should encourage database refactoring, not discourage it. Therefore, you should use as
few test data as possible, just enough to perform the test.</p>

<p>Data files should only fill columns that are involved in some kind of logic. This means filling up only the following columns:</p>

<ul>
    <li><p>ID columns</p></li>
    <li><p>Columns used in join conditions</p></li>
    <li><p>Columns used in the where clause of the query</p></li>
</ul>

<p>The columns specified above are part of a query’s logic. Other database fields used in the select queries are simply assigned to bean
properties in the tested method. This gives very little added value to your test, but it greatly increases its maintenance cost.</p>

<p>If you run into data files with too much data, try to simplify them.</p>

<ul>
    <li><p>Refactor different tests in a test class to make them make use of the same data (if possible)</p></li>
    <li><p>If one or more methods need very specific test data, create a specific data file for these methods (check the Unitils documentation)</p></li>
    <li><p>If a group of related tests can be identified, split them up into a separate test class.</p></li>
</ul>

</div>

<div class="section"><h3><a name="3.8">3.8 Make data sets test class specific</a></h3>

<h4>Short Description</h4>

<p>Don't reuse data sets between different test classes, for example, do not use 1 big domain data set for all your test classes. Doing 
so will make it very difficult to make changes to your test data for a test without braking anything for another test. You 
are writing a unit test and such a test should be independent of other tests.</p>
    
<h4>Description</h4>

<p>A common misconception is that time can be saved by creating one or a few general test data sets that can be reused by a large group of unit 
tests. This is in most cases not a good idea. The more unit tests reuse the same data set, the more brittle it becomes against changes.</p>

<p>Image the situation that you want to add a value for a column for testing a certain boundary condition. After doing the change, a number of existing tests 
appear to fail. As a reaction to this situation you will probably undo the change and try to find another way 
to test this boundary condition (or not test it at all). Probably you can avoid impacting existing tests by simply adding your test data to the data set. This will 
eventually result in a very large and incoherent dataset.</p>

<p>This doesn't mean you cannot share data among tests, because having more test data sets also brings along more maintenance. When changing the name of a database
column, for example, you will probably have to update multiple datasets to make all tests pass. These changes however are mostly simple and can be performed quickly.
A good practice is to use a test data set per test class and in some exceptional cases a specific data set for a method.</p>

</div>

<div class="section"><h3><a name="3.9">3.9 Use a DTD in your test data files</a></h3>


<h4>Short Description</h4>

<p>Refer to a DTD that represents your database in your DBUnit test data files, to enable code completion while editing them.</p>


<h4>Description</h4>

<p>Data files in DBUnit’s FlatXMLDataSet format can be written more rapidly when enabling code completion by using a DTD. If you use Unitils’ 
DBMaintainer system, a DTD will be automatically created or updated on each developer’s workstation when his unit test database is updated.</p>


<h4>Examples</h4>

<p>The test data file below shows how to use a DTD on the local file system.</p>

<div class="source"><pre>
&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;!DOCTYPE dataset SYSTEM &quot;../dtd/database.dtd&quot;&gt;
&lt;dataset&gt;

    &lt;user id=&quot;1&quot; username=&quot;jdoe&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@gmail.com&quot; /&gt;
    &lt;email userid=&quot;1&quot; emailaddress=&quot;jdoe@post.be&quot; /&gt;

&lt;/dataset&gt;
</pre></div>

</div>





<div class="section"><h3><a name="3.10">3.10 Do not test auto-generated fields</a></h3>


<h4>Short Description</h4>

<p>Don’t test fields that are automatically filled up by the underlying framework or database, like generated keys or timestamps.</p>


<h4>Description</h4>

<p>Databases tables generally contain columns like the id, created_by, created_on, last_updated_by, last_updated_on or version columns.
They are used for identity, basic tracking (e.g. find the cause for data loss or corruption) and optimistic locking.</p>

<p>The implementation of tracking / optimistic locking should be handled application-wide, by the persistence mechanism and/or by DAO
superclass methods. It is therefore not necessary to test it over and over again for every DAO method.</p>

</div>





<div class="section"><h3><a name="3.11">3.11 Modify database sequences</a></h3>


<h4>Short Description</h4>

<p>When using identity or auto-increment columns and sequences, make sure they have a high enough value for running the tests. This way they
don’t interfere with the test data.</p>


<h4>Description</h4>

<p>When a new sequence is created, it should be initialized to a sufficiently high value, so that auto generated ids and values don’t clash
with the ids and values of the test data files. When using Unitils' database maintainer for managing test database schema's, sequences and identity 
columns are automatically set to a configurable value after creation.</p>

</div>





<div class="section"><h3><a name="3.12">3.12 Don’t use transactions</a></h3>


<h4>Short Description</h4>

<p>Don’t run unit tests in a transaction, instead use auto-commit.</p>


<h4>Description</h4>

<p>In production code, DAO methods are always executed in a transaction. Some argue that DAO methods need also to be executed in a
transaction, so that the tests closely resemble the real situation. Running them in a transaction also has disadvantages:</p>

<ul>
    <li><p>When debugging tests using the IDE’s debugger, the data updates executed so far are not visible in a database query console like Toad or SqlPlus.</p></li>
    <li><p>Failing tests are difficult to debug afterwards if the transaction rolled back all changes to the database.</p></li>
    <li><p>Extra baseline code is required to enable transactions in unit tests.</p></li>
</ul>

</div>






<br />
<h2><a name="4">4. O/R mapping testing guidelines</a></h2>

<p>The past few years, most projects use some form of Object-Relational mapping framework such as Hibernate or some implementation of JPA (EJB3) Persistence. 
The use of such a mapping tool greatly simplifies the persistence layer in an application. Errors can still exist in the mapping of the domain objects with 
the database or in queries written in HQL or EJB3 QL. Unit tests still remain valuable for helping finding these errors quickly and efficiently.</p>

<p>The guidelines described in the <a href="#3">Database testing guidelines</a> also apply to testing with Hibernate. This chapter explains the specifics in 
testing with Hibernate.</p>


<div class="section"><h3><a name="4.1">4.1 Test mapping with database</a></h3>


<h4>Short Description</h4>

<p>Unit tests for simple CRUD methods are overkill when using Hibernate. Instead, use a generic test that verifies the complete mapping with the database.</p>


<h4>Description</h4>

<p><a href="#3.4">Testing simple CRUD methods</a> explains how CRUD methods can be tested when using plain old JDBC. When using Hibernate, the correct functioning of simple CRUD 
depends mainly on the correct mapping of the domain model objects with the database. Here are some typical mapping problems:</p>

<ul>
    <li><p>Expected table or column is missing in the database</p></li>
    <li><p>Database table or column has a different name as specified in the mapping</p></li>
    <li><p>The name of a property in the mapping file differs from the property in the domain model class</p></li>
    <li><p>A property of a certain class is not mapped</p></li>
</ul>

<p>The last 2 problems cannot occur when using annotations for defining the mapping with the database, only when using separate mapping files. These problems 
are usually easy to trace and to fix, but adding a unit test that verifies the complete mapping with the database all at once, helps in finding these problems 
quickly. This is also a very cheap solution, since you only have to define this unit test once. Experience on projects has learnt us that this test ends up to
be the most valuable test in the test suite.</p>

<p>The Unitils project contains a test, assertMappingToDatabase(), which implements the mapping check. The test works for both a configuration with Hibernate 
XML mapping files as when using annotations. See the Unitils tutorial for more information.</p>


<h4>Examples</h4>

<div class="source"><pre>
public class HibernateMappingTest extends BaseHibernateDAOTest {

    public void testMappingToDatabase() {
        HibernateUnitils.assertMappingWithDatabaseConsistent();
    }
}

</pre></div>

</div>





<div class="section"><h3><a name="4.2">4.2 Test non-trivial queries</a></h3>


<h4>Short Description</h4>

<p>Add unit tests for methods that implement HQL queries. The same rules apply as for testing queries in plain old JDBC.</p>


<h4>Description</h4>

<p>The guideline <a href="#3.5">Testing queries</a> explains how maintainable unit tests can be written for queries. The same rules apply for testing with HQL queries.</p>

</div>






<div class="section"><h3><a name="4.3">4.3 Test bulk data manipulation methods</a></h3>


<h4>Short Description</h4>

<p>Add unit tests for methods that implement bulk data manipulation. The same rules apply as for testing such methods written in plain old JDBC. Make sure 
the Hibernate Session is flushed before you access the test database trough plain old JDBC, without the intervenience of Hibernate</p>


<h4>Description</h4>

<p>The guideline <a href="#3.6">Testing bulk data manipulation methods</a> explains how unit tests can be written for bulk data manipulation methods. The same rules apply for 
testing with such methods written in HQL.</p>

<p>Make sure that, when comparing the database contents with a result data file, the Hibernate session is being flushed. Otherwise, the update that you 
want to test will most probably not be executed on the database yet when you perform the check. When making use of Unitils, the Hibernate session is automatically flushed
before doing the check.</p>

</div>

<br />
<br />



        
    </section>
  </body>
</document>