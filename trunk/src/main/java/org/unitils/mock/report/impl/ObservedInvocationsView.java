/*
 * Copyright 2008,  Unitils.org
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.unitils.mock.report.impl;

import static org.apache.commons.lang.StringUtils.uncapitalize;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.unitils.core.util.ObjectFormatter;
import org.unitils.mock.core.ObservedInvocation;

/**
 * A view that displays the observed invocations and the location where they were invoked.
 * The arguments are shown inline when the lenght is small enough, else the argument is named using the
 * type (eg Person => person1) and the actual value is displayed below the invocations.
 * <p/>
 * Example: <pre><code>
 * 1.  mock.method1()) -> string1  ..... at MyTest.testMethod(MyTest.java:60)
 * 2.  mock.method1("bla", 4) -> null  ..... at MyTest.testMethod(MyTest.java:62)
 * 3.  mock.anotherMethod(myClass1)  ..... at MyTest.testMethod(MyTest.java:64)
 *
 * string1 -> "1234567891234567890"
 * myClass1 -> MyClass<aField="hello">
 * <code></pre>
 *
 * @author Kenny Claes
 * @author Filip Neven
 * @author Tim Ducheyne
 */
public class ObservedInvocationsView {

    public static final int OBJECT_FORMATTER_MAX_RECURSION_DEPT = 10;
    
    /**
     * The maximum length of an inline value
     */
    public static int MAX_INLINE_PARAMETER_LENGTH = 20;


    /**
     * Formatter for arguments and return values
     */
    protected ObjectFormatter objectFormatter = new ObjectFormatter(OBJECT_FORMATTER_MAX_RECURSION_DEPT);

    /**
     * Creates a string representation of the given scenario as described in the class javadoc.
     * @param observedInvocations 
     *
     * @return The string representation, not null
     */
    public String createView(List<ObservedInvocation> observedInvocations) {
        StringBuilder result = new StringBuilder();

        Map<Class<?>, Integer> largeValueNameIndexes = new HashMap<Class<?>, Integer>();
        Map<String, String> formattedLargeValues = new HashMap<String, String>();

        // append all invocations
        int invocationIndex = 0;
        for (ObservedInvocation observedInvocation : observedInvocations) {
            result.append(formatInvocationIndex(++invocationIndex, observedInvocations.size()));
            result.append(formatObservedInvocation(observedInvocation, largeValueNameIndexes, formattedLargeValues));
            result.append(formatInvokedAt(observedInvocation));
            result.append("\n");
        }

        return result.toString();
    }


    /**
     * Formats the invocation number, and adds spaces to make sure everything is formatted
     * nicely on the same line width.
     *   
     * @param invocationIndex The index of the invcation
     * @param totalInvocationNumber The total number of invocations.
     * @return The formatted invocation number
     */
    protected String formatInvocationIndex(int invocationIndex, int totalInvocationNumber) {
        int padSize = String.valueOf(totalInvocationNumber).length() + 2;
        return StringUtils.rightPad(invocationIndex + ".", padSize);
    }


    /**
     * Creates a string representation of the given invocation.
     * If arguments and result values are small enough, they are displayed inline, else they are added
     * per type to the given large values map. Inline the value is replaced by a name generated by
     * the {@link #formatLargeValueName} method.
     *
     * @param observedInvocation   The invocation to format, not null
     * @param largeValueIndexes    The current indexes to use for the large value names (per value type), not null
     * @param formattedLargeValues The large values as strings, not null
     * @return The string representation, not null
     */
    protected String formatObservedInvocation(ObservedInvocation observedInvocation, Map<Class<?>, Integer> largeValueIndexes, Map<String, String> formattedLargeValues) {
        StringBuilder result = new StringBuilder();
        Method method = observedInvocation.getMethod();
        
        // append the mock and method name
        result.append(observedInvocation.getMockName());
        result.append('.');
        result.append(method.getName());

        // append the arguments
        result.append('(');
        Class<?>[] argumentTypes = method.getParameterTypes();
        if (argumentTypes.length > 0) {
            Iterator<Object> arguments = observedInvocation.getArguments().iterator();
            for (Class<?> argumentType : argumentTypes) {
                result.append(formatValue(arguments.next(), argumentType, largeValueIndexes, formattedLargeValues));
                result.append(", ");
            }
            // remove the last comma
            result.setLength(result.length() - 2);
        }
        result.append(")");

        // append the result value, if there is one (void methods do not have mock behavior)
        Class<?> resultType = method.getReturnType();
        if (!Void.TYPE.equals(resultType)) {
            result.append(" -> ");
            String resultAsString = objectFormatter.format(observedInvocation.getResult());
            result.append(formatValue(resultAsString, resultType, largeValueIndexes, formattedLargeValues));
        }
        return result.toString();
    }


    /**
     * Creates a string representation of the details of the given invocation. This will give information about
     * where the invocation occurred.
     *
     * @param observedInvocation The invocation to format, not null
     * @return The string representation, not null
     */
    protected String formatInvokedAt(ObservedInvocation observedInvocation) {
        return "  ..... at " + observedInvocation.getInvokedAt();
    }


    /**
     * Formats the given value. If the value is small enough (lenght <=20), the value itself is returned, else
     * the value is added to the large values map and a name is returned generated by
     * the {@link #formatLargeValueName} method.
     * <p/>
     * E.g. string1, myClass1
     *
     * @param value                The value to format, not null
     * @param type                 The type of the large value, not null
     * @param largeValueNameIndexes    The current indexes to use for the large value names (per value type), not null
     * @param formattedLargeValues The large values as strings, not null
     * @return The value or the replaced name, not null
     */
    protected String formatValue(Object object, Class<?> type, Map<Class<?>, Integer> largeValueNameIndexes, Map<String, String> objectsWithLargeRepresentation) {
        String objectRepresentation = objectFormatter.format(object);
        if (objectRepresentation.length() <= MAX_INLINE_PARAMETER_LENGTH) {
            // The object representation is small enough to be shown inline
            return objectRepresentation;
        }
        // The object representation is to large to be shown inline. Generate a name for it, which can be shown as a replacement.
        String largeValueName = createLargeValueName(type, largeValueNameIndexes);
        objectsWithLargeRepresentation.put(largeValueName, objectRepresentation);
        return largeValueName;
    }


    /**
     * Creates a name to replace a large value.
     * The name is derived from the given type and index. E.g. string1, myClass1
     *
     * @param type  The type of the large value, not null
     * @param index The current index
     * @return The name, not null
     */
    protected String createLargeValueName(Class<?> type, Map<Class<?>, Integer> largeValueNameIndexes) {
        Integer index = largeValueNameIndexes.get(type);
        if (index == null) {
            index = 0;
        }
        largeValueNameIndexes.put(type, ++index);
        
        String result = uncapitalize(type.getSimpleName());
        return result + index;
    }
}
