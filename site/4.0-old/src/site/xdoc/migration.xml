<document>
    <properties>
        <title>Migration path</title>
    </properties>
    <body>
        <section name="Migration to 2.0">
            <p>For databases managed by unitils, a different table is used to store information about the current status of the database.
               This table is called DBMAINTAIN_SCRIPTS and contains a record for every script that was executed. The next time you update your database,
               the DbMaintainer will fail because this table doesn't exist yet. The error message also contains the DDL for creating this table.
               You can make sure this table is created automatically by setting the property dbMaintainer.autoCreateExecutedScriptsTable to true.
            </p>
            <p>
               The dbmaintainer no longer supports post-processing scripts configured using the property dbMaintainer.postProcessingScript.locations. Instead, 
               you can define one or more directories relative to the scripts location that contain post-processing scripts using the property 
               dbMaintainer.postProcessingScript.directoryName. By default, scripts inside the directory called 'postprocessing' are regarded as 
               postprocessing scripts.
            </p>
        </section>
        <section name="Migration to 1.1-rc-2">
            <p>In 1.1-rc-2 we've made the migration of the DB_VERSION table more explicit. If a version table is found that uses the old structure,
                an exception is raised. The new structure should contain a column <i>version_indexes</i> instead of <i>version_index</i>.
            </p>
            <p>The easiest way to migrate to the new version table structure, is to drop the old one and then recreate the new one using the create
                statement that was specified in the exception. If you then run your tests, it will re-create the unit test database from scratch (if enabled)
                and update the version table to the correct version. If you don't want to do this, you can also use the values of the old version record and
                use the value of the version_index column for the version_indexes column adding the indexes of the parent folders.
            </p>
            <p>For example: suppose you have following scripts folder structure:
                <ul>
                    <li>scripts/ 01_scriptA.sql</li>
                    <li>scripts/ 02_scriptB.sql</li>
                </ul>
                The value of the old <i>version_index</i> column would be <b>2</b> since <i>02_scriptB</i> has the highest script version. For the new
                <i>version_indexes</i> column you will then need to use value <b>x.2</b> because there is no index for the parent folder <i>scripts</i>.
            </p>
            <p>Suppose you have following scripts folder structure:
                <ul>
                    <li>003_scripts/ 01_scriptA.sql</li>
                    <li>003_scripts/ 02_scriptB.sql</li>
                </ul>
                The value of the old <i>version_index</i> column would be <b>2</b> since <i>02_scriptB</i> has the highest script version. For the new
                <i>version_indexes</i> column you will then need to use value <b>3.2</b> because 3 is the index for the parent folder <i>scripts</i>.
            </p>
        </section>
        <section name="Migration to 1.1-rc-1">

            <p>When migrating from Unitils 1.0 to 1.1-rc-1, following changes need to be made:</p>

            <p>If you're using the DBMaintainer: In the first place, the property dbMaintainer.fileScriptSource.scripts.locations must be renamed to dbMaintainer.script.locations.
                We also advise you to read the section on automatic test database maintenance in the tutorial. The DBMaintainer has a lot of new features such as:
                <ul>
                    <li>Support for organising scripts in folders that also have a version number</li>
                    <li>Support for Oracle PL/SQL, mixed with simple SQL and DDL statements</li>
                    <li>Support for version-less scripts, that are re-executed each time they are changed, without triggering a from-scratch update of the database (ideal for maintaining functions and stored procedures)</li>
                </ul>
            </p>

            <p>If you're using Unitils' hibernate integration:
                <ul>
                    <li>Every test that uses hibernate, must be run in a transaction. Add @Transactional(TransactionMode.COMMIT) or @Transactional(TransactionMode.ROLLBACK) on
                        you test (super)class.
                    </li>
                    <li>For configuring a SessionFactory, custom create methods are no longer supported. Custom configuration methods are still supported. You can easily
                        migrate a custom create method to a custom configuration method, e.g.:
                    </li>
                </ul>
            </p>

            <p>
                <pre>
                    <code>
                        @HibernateSessionFactory
                        protected Configuration createConfiguration() {
                        AnnotationConfiguration configuration = new AnnotationConfiguration();
                        configuration.loadConfig("hibernate.cfg.xml");
                        configuration.addAnnotatedClass(Person.class);
                        configuration.addAnnotatedClass(Car.class);
                        }
                    </code>
                </pre>
            </p>
            Can be re-implemented as:
            <p>
                <pre>
                    <code>
                        @HibernateSessionFactory
                        protected void createConfiguration(AnnotationConfiguration configuration) {
                        configuration.loadConfig("hibernate.cfg.xml");
                        configuration.addAnnotatedClass(Person.class);
                        configuration.addAnnotatedClass(Car.class);
                        }
                    </code>
                </pre>
            </p>

            <p>If you're using JPA with hibernate, toplink or openjpa as persistence provider, then try out unitils' brand new JPA support for testing your persistence layer code!</p>
        </section>
        <section name="Migration to 1.0-rc-4">

            <p>When migrating from Unitils 1.0-rc-3 to 1.0-rc-4, following changes need to be made:</p>

            <p>If no file name is specified for the @DataSet annotation, Unitils will no longer first look for a file named
                <i>className.methodName</i>.xml.
                It will only look for a file named<i>className</i>.xml.
            </p>

            <p>All uses of method-specific data sets must therefore be replaced by explicitily loading the data set file. So, suppose you have a method-specific
                data set named
                <i>UserDAOTest.testFindByMinimalAge.xml</i>, this will no longer be loaded in following example:
            </p>

            <p>
                <pre>
                    <code>
                        @DataSet
                        public class UserDAOTest extends UnitilsJUnit4 {

                        public void testFindByMinimalAge() {
                        }
                        }
                    </code>
                </pre>
            </p>

            This should be replaced by explicitly loading the data set on method-level.

            <p>
                <pre>
                    <code>
                        @DataSet
                        public class UserDAOTest extends UnitilsJUnit4 {

                        @DataSet("UserDAOTest.testFindByMinimalAge.xml")
                        public void testFindByMinimalAge() {
                        }
                        }
                    </code>
                </pre>
            </p>

        </section>
        <section name="Migration to 1.0-rc-3">

            <p>When migrating from Unitils 1.0-rc-2 to 1.0-rc-3, following changes need to be made:</p>

            <p>Rename the property
                <i>database.schemaName</i>
                to
                <i>database.schemaNames</i>
                in your configuration files. Multiple schema names may be
                specified, seperated by commas.
            </p>

            <p>By default, the DBMaintainer will generate a number of XSDs describing your database instead of a DTD. If you want to continue using DTD's, you have to
                add the property
                <i>org.unitils.dbmaintainer.structure.DataSetStructureGenerator.implClassName</i>
                to your configuration with value
                <i>org.unitils.dbmaintainer.structure.impl.DtdDataSetStructureGenerator</i>. You also have to rename the property
                <i>dtdGenerator.dtd.filename</i>
                to
                <i>dataSetStructureGenerator.dtd.filename</i>. If you want to switch to using XSD's (recommended), specify the path to the directory where the XSD files should be
                put in the property<i>dataSetStructureGenerator.xsd.dirName</i>.
            </p>

            <p>If present in your config, the property
                <i>dbMaintainer.cleanDb.tablesToPreserve</i>
                needs to be renamed to<i>dbMaintainer.preserveDataOnly.tables</i>. Table names may
                optionally be prefixed by their schema name. If all the tables from a certain database schema need to be preserved, you can specify this schema in
                <i>dbMaintainer.preserveDataOnly.schemas</i>.
            </p>

            <p>
                <i>dbMaintainer.clearDb.itemsToPreserve</i>
                has been split up into multiple properties, for different types of database items. If you specified this property, move
                your items to preserve to one of the properties<i>dbMaintainer.preserve.tables</i>,
                <i>dbMaintainer.preserve.views</i>,
                <i>dbMaintainer.preserve.synonyms</i>
                or
                <i>dbMaintainer.preserve.sequences</i>. Identifiers may optionaly be prefixed by their schema name. If all the tables from a certain database schema need to be
                preserved, you can specify this schema in<i>dbMaintainer.preserve.schemas</i>.
            </p>

        </section>
    </body>
</document>
