Reflection Assert
~~~~~~~~~~~~~~~~~

* {Installation}
~~~~~~~~~~~~~~~~
    If you are using maven, you can add following dependency to your project.

%{include|source=pom.xml|id=core|verbatim=true|set-first-line=1|pad-line-numbers=2}

    If you are not using maven you can download the unitils-with-dependencies.zip. The required jar, unitils.jar, can be
    found in the unitils folder, the required dependencies, in the unitils/lib folder.


* {Using reflection for assertion}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    A typical unit test contains a part in which it compares test result values with expected values. Unitils offers assertion utilities to
    help you with this. Let's start with an example of comparing 2 <User> instances having an id, a first and a last name:

%{include|source=org/unitils/reflectionassert/User.java|id=user|verbatim=true|set-first-line=1|pad-line-numbers=2}

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=noEquals|verbatim=true|set-first-line=1|pad-line-numbers=2}

    You could expect this assertion to be successful since both instances contain the same values. This is however not the case, because <User>
    does not override the <equals()> method. Checking equals of 2 <User> instances is in that case the same as checking whether both instances are the same.
    In other words, the assertEquals actually results in user1 == user2 being tested causing the assertion to fail.

    Suppose you implemented the equals method as follows:

%{include|source=org/unitils/reflectionassert/UserWithEquals.java|id=equals|verbatim=true|set-first-line=1|pad-line-numbers=2}

    This is a totally reasonable implementation for your application logic, stating that 2 user instances are referring to the same user when they have the
    same id. However, this method is not useful in your unit tests. Testing whether 2 objects are equal is now reduced to the test whether they both have
    the same id:

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=usingEquals|verbatim=true|set-first-line=1|pad-line-numbers=2}

    This assertion will be successful, which is probably not what you want. Best is to avoid using <equals()> altogether
    when comparing objects (except of course for objects with value semantics such as java.lang.String, ...).
    One approach can be to do the comparison of each of the properties one by one:

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=allFields|verbatim=true|set-first-line=1|pad-line-numbers=2}

    Unitils offers utilities that help you perform these checks more easily, through reflection. Using <ReflectionAssert.assertReflectionEquals>,
    the above example could be re-written as follows:

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=reflection|verbatim=true|set-first-line=1|pad-line-numbers=2}

    This assertion loops over all fields in both objects and compares their values using reflection. For the above example, it will
    first compare both <id> field values, next both <first> field values and finally both <last> fields values.

    If a field value itself is also an object, it will recursively be compared field by field using reflection. The same is true for
    collections, maps and arrays. Their elements will be traversed and recursively be compared using reflection. If a value is a primitive
    type (int, long, ...) or one of the primitive wrapper types (Integer, Long, ...) it will be compared by value (using ==).
    As a result, following assertions will be successful:

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=examples|verbatim=true|set-first-line=1|pad-line-numbers=2}



* Lenient assertions
~~~~~~~~~~~~~~~~~~~~~
    For reasons of maintainability, it's important to only add assertions that are of value for the test. Let me clarify this with an
    example: suppose you have a test for a calculation of an account balance. There is no need to add any assertions to this test that will check the value of the name of
    the bank-customer. This will only add complexity to your test making it more difficult to understand and, more importantly, more brittle against changes
    to the code. If you want your test code to easily survive refactorings and other code changes, make sure you limit your assertions and
    test data setup to the scope of the test.

    To help you in writing such assertions we added some levels of leniency to the ReflectionAssert checks. We'll cover these leniency levels in the
    sections that follow.


** Lenient order
~~~~~~~~~~~~~~~~
    A first type of leniency you can specify is ignoring the order of elements in a collection or array. When working with lists, you are often not interested in
    the actual order of the elements. For example, code for retrieving all bank-accounts with a negative balance will typically
    return them in an order that is unimportant for the actual processing.

    To implement this behavior, the <ReflectionAssert.assertReflectionEquals> method can be configured to ignore ordering by supplying it the <ReflectionComparatorMode.LENIENT_ORDER>
    comparator mode:

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=lenientOrder|verbatim=true|set-first-line=1|pad-line-numbers=2}


** Ignoring defaults
~~~~~~~~~~~~~~~~~~~~
    A second type of leniency is specified by the <ReflectionComparatorMode.IGNORE_DEFAULTS> mode. When this mode is set, java default values, like <null> for objects
    and <0> or <false> for values are ignored. In other words, only the fields that you instantiate in your expected objects are used in the comparison.

    As an example, suppose you have a user class with a first name, last name, street... field, but you only want to check that the resulting user instance has
    a certain first name and street value, ignoring the other field values:

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=ignoreDefaults|verbatim=true|set-first-line=1|pad-line-numbers=2}

    You specify that you want to ignore a field by setting this value to null in the left (=expected) instance. Right-instance fields that have default
    values will still be compared.

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=ignoreDefaultsSide|verbatim=true|set-first-line=1|pad-line-numbers=2}


** Lenient dates
~~~~~~~~~~~~~~~~
    A third type of leniency is <ReflectionComparatorMode.LENIENT_DATES>. This will assert that the date field values in both instances
    are both set or both equal to null; the actual values of the dates are ignored. This can be useful if you want to do strict checking
    on the fields of objects (without using <ReflectionComparatorMode.IGNORE_DEFAULTS>), but there are fields in your object set to the
    current date or time that you want to ignore.

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=lenientDates|verbatim=true|set-first-line=1|pad-line-numbers=2}


** assertLenientEquals
~~~~~~~~~~~~~~~~~~~~~~
    The <ReflectionAssert> class also offers an assertion for which two of the leniency levels, lenient order and ignore defaults are pre-set:
    <ReflectionAssert.assertLenientEquals>. The above examples can therefore be simplified as follows:

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=lenientEquals|verbatim=true|set-first-line=1|pad-line-numbers=2}

    This len/ref thing is a general naming convention: assert<<Reflection>>... is the version that is strict by default and for which you can
    manually set the leniency levels, assert<<Lenient>>... is the version for which the lenient order and ignore defaults are pre-set.



* Property assertions
~~~~~~~~~~~~~~~~~~~~~
    The <assertLenientEquals> and <assertReflectionEquals> methods compare objects as a whole. ReflectionAssert also contains methods to compare
    a specific property of two objects: <assertPropertyLenientEquals> and <assertPropertyReflectionEquals>. The actual field that needs to be compared
    is specified using the {{{http://www.ognl.org/}OGNL}} notation. This language supports typical bean property expressions, like
    field1.innerField and a number of more powerful constructions.

    Some examples of property comparisons are:

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=propertyAssertions|verbatim=true|set-first-line=1|pad-line-numbers=2}

    You can also supply collections as arguments for this method. In that case the specified field will be compared on each element in the collection. This
    provides an easy way to for example check whether all users in a retrieved list have certain id:

%{include|source=org/unitils/reflectionassert/ReflectionAssertExamples.java|id=collectionPropertyAssertions|verbatim=true|set-first-line=1|pad-line-numbers=2}

    Again there are two versions of each method: assertProperty<<Reflection>>Equals and assertProperty<<Lenient>>Equals .
    The ref version doesn't have leniency specified by default but provides the option to specify leniency modes, the len version
    has lenient order and ignore defaults set as fixed leniency modes.

